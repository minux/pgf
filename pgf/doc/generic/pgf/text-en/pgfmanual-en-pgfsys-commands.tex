% Copyright 2006 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.


\section{Commands of the System Layer}

\makeatletter

\subsection{Beginning and Ending a Stream of System Commands}

A ``user'' of the \pgfname\ system layer (like the basic layer or a
frontend) will interface with the system layer by calling a stream of
commands starting with |\pgfsys@|. From the system layer's point of
view, these commands form a long stream. Between calls to the system
layer, control goes back to the user.

The driver files implement system layer commands by inserting
|\special| commands that implement the desired operation. For example,
|\pgfsys@stroke| will be mapped to |\special{pdf: S}| by the driver
file for |pdftex|.

For many drivers, when such a stream of specials starts, it is
necessary to install an appropriate transformation and perhaps perform
some more bureaucratic tasks. For this reason, every stream will start
with a |\pgfsys@beginpicture| and will end with a corresponding ending
command.

\begin{command}{\pgfsys@beginpicture}
  Called at the beginning of a |{pgfpicture}|. This command should
  ``set up things.''

  Most drivers will need to implement this command.
\end{command}

\begin{command}{\pgfsys@endpicture}
  Called at the end of a |{pgfpicture}|.

  Most drivers will need to implement this command.
\end{command}

\begin{command}{\pgfsys@typesetpicturebox\marg{box}}
  Called \emph{after} a |{pgfpicture}| has been typeset. The picture
  will have been put in box \meta{box}. This command should insert the
  box into the normal text. The box \meta{box} will still be a ``raw''
  box that contains only the |\special|'s that make up the description
  of the picture. The  job of this command is to resize and shift
  \meta{box} according to the  baseline shift and the size of the
  box.

  This command has a default implementation and need not be
  implemented by a driver file.
\end{command}

\begin{command}{\pgfsys@beginpurepicture}
  This version of the |\pgfsys@beginpicture| picture command can be
  used for pictures that are guaranteed not to contain any escaped
  boxes (see below). In this case, a driver might provide a more
  compact version of the command.

  This command has a default implementation and need not be
  implemented by a driver file.
\end{command}

\begin{command}{\pgfsys@endpurepicture}
  Called at the end of a ``pure'' |{pgfpicture}|.

  This command has a default implementation and need not be
  implemented by a driver file.
\end{command}

Inside a stream it is sometimes necessary to ``escape'' back into
normal typesetting mode; for example to insert some normal text, but
with all of the current transformations and clippings being in
force. For this escaping, the following command is used:

\begin{command}{\pgfsys@hbox\marg{box number}}
  Called to insert a (horizontal) TeX box inside a
  |{pgfpicture}|.

  Most drivers will need to (re-)implement this command.
\end{command}

\begin{command}{\pgfsys@hboxsynced\marg{box number}}
  Called to insert a (horizontal) TeX box inside a
  |{pgfpicture}|, but with the current coordinate transformation
  matrix synced with the canvas transformation matrix.

  This command should do the same as if you used
  |\pgflowlevelsynccm| followed by |\pgfsys@hbox|. However, the default
  implementation of this command will use a ``TeX-translation'' for
  the translation part of the transformation matrix. This will ensure
  that hyperlinks ``survive'' at least translations. On the other
  hand, a driver may choose to revert to a simpler
  implementation. This is done, for example, for the \textsc{svg}
  implementation, where a \TeX-translation makes no sense.
\end{command}

\begin{command}{\pgfsys@pictureboxsynced\marg{box number}}
  Basically, this should do the same as doing a (scoped) low level sync
  followed by inserting the box \meta{box number} directly into the
  output stream. However, the default implementation uses
  |\pgfsys@hboxsynced| in conjunction with |\pgfsys@beginpicture| to
  ensure that, if possible, hyperlinks survive in
  \textsc{pdf}s. Drivers that are sensitive to picture-in-picture
  scopes should replace this implementation by
\begin{codeexample}[code only]
\pgfsys@beginscope\pgflowlevelsynccm\box#1\pgfsys@endscope
\end{codeexample}
\end{command}



\subsection{Scoping System Commands}

The scoping commands are used to keep changes of the graphics state
local.

\begin{command}{\pgfsys@beginscope}
  Saves the current graphic state on a graphic state stack. All
  changes to the graphic state parameters mentioned for |\pgfsys@stroke|
  and |\pgfsys@fill| will be local to the current graphic state and
  the old values will be restored after |\pgfsys@endscope| is used.

  \emph{Warning:} \pdf\ and PostScript differ with respect to the
  question of whether the current path is part of the graphic state or
  not. For this reason, you should never use this command unless the
  path is currently empty. For example, it might be a good idea to use
  |\pgfsys@discardpath| prior to calling this command.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@endscope}
  Restores the last saved graphic state.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}




\subsection{Path Construction System Commands}

\begin{command}{\pgfsys@moveto\marg{x}\marg{y}}
  This command is used to start a path at a specific point
  $(x,y)$ or to move the current point of the current path to  $(x,y)$
  without drawing anything upon stroking (the current path is
  ``interrupted'').

  Both \meta{x} and \meta{y} are given as \TeX\ dimensions. It is the
  driver's job to transform these to the coordinate system of the
  backend. Typically, this means converting the \TeX\ dimension into a
  dimensionless multiple of $\frac{1}{72}\mathrm{in}$. The function
  |\pgf@sys@bp| helps with this conversion.

  \example Draw a line from $(10\mathrm{pt},10\mathrm{pt})$ to the
  origin of the picture.
\begin{codeexample}[code only]
\pgfsys@moveto{10pt}{10pt}
\pgfsys@lineto{0pt}{0pt}
\pgfsys@stroke
\end{codeexample}

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@lineto\marg{x}\marg{y}}
  Continue the current path to $(x,y)$ with
  a straight line.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@curveto\marg{$x_1$}\marg{$y_1$}\marg{$x_2$}\marg{$y_2$}\marg{$x_3$}\marg{$y_3$}}
  Continue the current path to $(x_3,y_3)$
  with a B\'ezier curve that has the two control points  $(x_1,y_1)$ and  $(x_2,y_2)$.

  \example Draw a good approximation of a quarter circle:
\begin{codeexample}[code only]
\pgfsys@moveto{10pt}{0pt}
\pgfsys@curveto{10pt}{5.55pt}{5.55pt}{10pt}{0pt}{10pt}
\pgfsys@stroke
\end{codeexample}

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@rect\marg{x}\marg{y}\marg{width}\marg{height}}
  Append a rectangle to the current path whose lower left corner is
  at $(x,y)$ and whose width and height in
  big points are  given by \meta{width} and \meta{height}.

  This command can be ``mapped back'' to |\pgfsys@moveto| and
  |\pgfsys@lineto| commands, but it is included since \pdf\ has a
  special, quick version of this command.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@closepath}
  Close the current path. This results in joining the current point of
  the path with the point specified by the last |\pgfsys@moveto|
  operation. Typically, this is preferable over using |\pgfsys@lineto|
  to the last point specified by a |\pgfsys@moveto|, since the line
  starting at this point and the line ending at this point will be
  smoothly joined by |\pgfsys@closepath|.

  \example Consider
\begin{codeexample}[code only]
\pgfsys@moveto{0pt}{0pt}
\pgfsys@lineto{10bp}{10bp}
\pgfsys@lineto{0bp}{10bp}
\pgfsys@closepath
\pgfsys@stroke
\end{codeexample}
  and
\begin{codeexample}[code only]
\pgfsys@moveto{0bp}{0bp}
\pgfsys@lineto{10bp}{10bp}
\pgfsys@lineto{0bp}{10bp}
\pgfsys@lineto{0bp}{0bp}
\pgfsys@stroke
\end{codeexample}

  The difference between the above will be that in the second triangle
  the corner at the origin will be wrong; it will just be the overlay
  of two lines going in different directions, not a sharp pointed
  corner.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}




\subsection{Canvas Transformation System Commands}

\begin{command}{\pgfsys@transformcm\marg{a}\marg{b}\marg{c}\marg{d}\marg{e}\marg{f}}
  Perform a concatenation of the canvas transformation matrix with the
  matrix given by the values \meta{a} to \meta{f}, see the \pdf\ or
  PostScript manual for details. The values \meta{a} to \meta{d} are
  dimensionless factors, \meta{e} and \meta{f} are \TeX\ dimensions

  \example |\pgfsys@transformcm{1}{0}{0}{1}{1cm}{1cm}|.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@transformshift\marg{x displacement}\marg{y displacement}}
  This command will change the origin of the canvas to $(x,y)$.

  This command has a default implementation and need not be
  implemented by a driver file.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@transformxyscale\marg{x scale}\marg{y scale}}
  This command will scale the canvas (and  everything that is drawn)
  by a factor of \meta{x scale} in the $x$-direction and \meta{y
    scale} in the  $y$-direction. Note that this applies to
  everything, including  lines. So a scaled line will have a different
  width and may even have a different width when going along the
  $x$-axis and when going along the $y$-axis, if the scaling is
  different in these directions. Usually, you do not want this.

  This command has a default implementation and need not be
  implemented by a driver file.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@viewboxmeet\marg{$x_1$}\marg{$y_1$}\marg{$x_2$}\marg{$y_2$}%
    \marg{$x'_1$}\marg{$y'_1$}\marg{$x'_2$}\marg{$y'_2$}}
  Starts a ``view box'' scope, which must be ended using
  |\pgfsys@endviewbox| later on (with matching scopes).

  The effect of this command is as follows: Consider the rectangles $R$
  with lower left corner $(x_1,y_1)$ and upper right corner
  $(x_2,y_2)$ and $R'$ with corners $(x'_1,y'_1)$ and
  $(x'_2,y'_2)$. The command will install a canvas translation and
  uniform scaling such that $R'$ then has the same center as~$R$ and
  additionally, has maximum size such that it still fits
  inside~$R$. (Think of this as ``viewing'' $R'$ through $R$ such that
  the aspect ratio is kept.)
  
  This command has a default implementation. Its main purpose is to
  allow animations of the view box; for static drawings it is better
  to compute the necessary transformations directly.
\end{command}

\begin{command}{\pgfsys@viewboxslice\marg{$x_1$}\marg{$y_1$}\marg{$x_2$}\marg{$y_2$}%
    \marg{$x'_1$}\marg{$y'_1$}\marg{$x'_2$}\marg{$y'_2$}}
  Works like the previous command, but now $R'$ has minimal size such
  that it encompasses all of $R$.
\end{command}

\begin{command}{\pgfsys@endviewbox}
  Ends a viewbox previously started using |\pgfsys@viewboxmeet| or the
  |...slice| variant.
\end{command}


\subsection{Stroking, Filling, and Clipping System Commands}

\begin{command}{\pgfsys@stroke}
  Stroke the current path (as if it were drawn with a pen). A number
  of graphic state parameters influence this, which can be
  set using appropriate system commands described later.

  \begin{description}
  \item[Line width]
    The ``thickness'' of the line. A width of 0 is the thinnest width
    renderable on the device. On a high-resolution printer this may
    become invisible and should be avoided. A good choice is 0.4pt,
    which is the default.

  \item[Stroke color]
    This special color is used for stroking. If it is not set, the
    current color is used.

  \item[Cap]
    The cap describes how the endings of lines are drawn. A round cap
    adds a little half circle to these endings. A butt cap ends the
    lines exactly at the end (or start) point without anything
    added. A rectangular cap ends the lines like the butt cap, but the
    lines protrude over the endpoint by the line thickness. (See also
    the \pdf\ manual.) If the path has been closed, no cap
    is drawn.

  \item[Join]
    This describes how a bend (a join) in a path is rendered. A round
    join draws bends using small arcs. A bevel join just draws the two
    lines and then fills the join minimally so that it becomes
    convex. A miter join extends the lines so that they form a single
    sharp corner, but only up to a certain miter limit. (See the \pdf\
    manual once more.)

  \item[Dash]
    The line may be dashed according to a dashing pattern.

  \item[Clipping area]
    If a clipping area is established, only those parts of the path
    that are inside the clipping area will be drawn.
  \end{description}

  In addition to stroking a path, the path may also be used for
  clipping after it has been stroked. This will happen if the
  |\pgfsys@clipnext| is used prior to this command, see there for
  details.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@closestroke}
  This command should have the same effect as first closing the path
  and then stroking it.

  This command has a default implementation and need not be
  implemented by a driver file.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@fill}
  This command fills the area surrounded by the current path. If the
  path has not yet been closed, it is closed prior to filling. The
  path itself is not stroked. For self-intersecting paths or paths
  consisting of multiple parts, the nonzero winding number rule is
  used to determine whether a point is inside or outside the
  path, except if |\ifpgfsys@eorule| holds -- in which case the
  even-odd rule should be used. (See the \pdf\ or PostScript manual
  for details.)

  The following graphic state parameters influence the filling:

  \begin{description}
  \item[Interior rule]
    If |\ifpgfsys@eorule| is set, the even-odd rule is used, otherwise
    the non-zero winding number rule.

  \item[Fill color]
    If the fill color is not especially set, the current color is
    used.

  \item[Clipping area]
    If a clipping area is established, only those parts of the filling
    area that are inside the clipping area will be drawn.
  \end{description}

  In addition to filling the path, the path will also be used for
  clipping if |\pgfsys@clipnext| is used prior to this command.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@fillstroke}
  First, the path is filled, then the path is stroked. If the fill and
  stroke colors are the same (or if they are not specified and the
  current color is used), this yields almost the same as a
  |\pgfsys@fill|. However, due to the line thickness of the stroked
  path, the fill-stroked area will be slightly larger.

  In addition to stroking and filling the path, the path will also be
  used for clipping if |\pgfsys@clipnext| is used prior to this command.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@discardpath}
 Normally, this command should ``throw away'' the current path.
 However, after |\pgfsys@clipnext| has been called, the current path
 should subsequently be used for clipping. See |\pgfsys@clipnext| for
 details.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@clipnext}
  This command should be issued after a path has been constructed, but
  before it has been stroked and/or filled or discarded. When the
  command is used, the next stroking/filling/discarding command will
  first be executed normally. Then, afterwards, the just-used path
  will be used for subsequent clipping. If there has already been a
  clipping region, this region is intersected with the new clipping
  path (the clipping cannot get bigger). The nonzero winding number
  rule is used to determine whether a point is inside or outside the
  clipping area or the even-odd rule, depending on whether
  |\ifpgfsys@eorule| holds.
\end{command}




\subsection{Graphic State Option System Commands}

\begin{command}{\pgfsys@setlinewidth\marg{width}}
  Sets the width of lines, when stroked, to \meta{width}, which must
  be a \TeX\ dimension.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@buttcap}
  Sets the cap to a butt cap. See |\pgfsys@stroke|.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@roundcap}
  Sets the cap to a round cap. See |\pgfsys@stroke|.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@rectcap}
  Sets the cap to a rectangular cap. See |\pgfsys@stroke|.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@miterjoin}
  Sets the join to a miter join. See |\pgfsys@stroke|.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@setmiterlimit\marg{factor}}
  Sets the miter limit of lines to \meta{factor}. See
  the \pdf\ or PostScript for details on what the miter limit is.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@roundjoin}
  Sets the join to a round join. See |\pgfsys@stroke|.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@beveljoin}
  Sets the join to a bevel join. See |\pgfsys@stroke|.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@setdash\marg{pattern}\marg{phase}}
  Sets the dashing patter. \meta{pattern} should be a list of \TeX\
  dimensions separated by commas. \meta{phase} should be a
  single dimension.

  \example |\pgfsys@setdash{3pt,3pt}{0pt}|

  The list of values in \meta{pattern} is used to determine the
  lengths of the ``on'' and ``off'' phases of the dashing. For example, if \meta{pattern} is |3bp,4bp|, then the dashing
  pattern is ``3bp on followed by 4bp off, followed by 3bp on,
  followed by 4bp off, and so on.'' A pattern of |.5pt,4pt,3pt,1.5pt| means
  ``.5pt on, 4pt off, 3pt on, 1.5pt off, .5pt on, \dots'' If the
  number of entries is odd, the last one is used twice, so |3pt| means
  ``3pt on, 3pt off, 3pt on, 3pt off, \dots'' An empty list
  means  ``always on.''

  The second argument determines the ``phase'' of the pattern. For
  example, for a pattern of |3bp,4bp| and a phase of |1bp|, the pattern
  would start: ``2bp on, 4bp off, 3bp on, 4bp off, 3bp on, 4bp off,
  \dots''

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

{\let\ifpgfsys@eorule=\relax
\begin{command}{\ifpgfsys@eorule}
  Determines whether the even odd rule is used for filling and
  clipping or not.
\end{command}
}


\subsection{Color System Commands}

The \pgfname\ system layer provides a number of system commands for
setting colors. These command coexist with commands from the |color|
and |xcolor| package, which perform similar functions. However, the
|color| package does not support having two different colors for
stroking and filling, which is a useful feature that is supported by
\pgfname. For this reason, the \pgfname\ system layer offers commands for
setting these colors separately. Also, plain \TeX\ profits from the
fact that \pgfname\ can set colors.

For \pdf, implementing these color commands is easy since \pdf\
supports different stroking and filling colors directly. For
PostScript, a more complicated approach is needed in which the colors
need to be stored in special PostScript variables that are set
whenever a stroking or a filling operation is done.

\begin{command}{\pgfsys@color@rgb\marg{red}\marg{green}\marg{blue}}
  Sets the color used for stroking and filling operations to the given
  red/green/blue tuple (numbers between 0 and 1).

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@rgb@stroke\marg{red}\marg{green}\marg{blue}}
  Sets the color used for stroking operations to the given
  red/green/blue tuple (numbers between 0 and 1).

  \example Make stroked text dark red: |\pgfsys@color@rgb@stroke{0.5}{0}{0}|

  The special stroking color is only used if the stroking color has
  been set since the last |\color| or |\pgfsys@color@...|
  command. Thus, each |\color| command will reset both the stroking
  and filling colors by calling |\pgfsys@color@reset|.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@rgb@fill\marg{red}\marg{green}\marg{blue}}
  Sets the color used for filling operations to the given
  red/green/blue tuple (numbers between 0 and 1). This color may be
  different from the stroking color.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@cmyk\marg{cyan}\marg{magenta}\marg{yellow}\marg{black}}
  Sets the color used for stroking and filling operations to the given
  cmyk tuple (numbers between 0 and 1).

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@cmyk@stroke\marg{cyan}\marg{magenta}\marg{yellow}\marg{black}}
  Sets the color used for stroking operations to the given cmyk tuple
  (numbers between 0 and 1).

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@cmyk@fill\marg{cyan}\marg{magenta}\marg{yellow}\marg{black}}
  Sets the color used for filling operations to the given cmyk tuple
  (numbers between 0 and 1).

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@cmy\marg{cyan}\marg{magenta}\marg{yellow}}
  Sets the color used for stroking and filling operations to the given
  cmy tuple (numbers between 0 and 1).

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@cmy@stroke\marg{cyan}\marg{magenta}\marg{yellow}}
  Sets the color used for stroking operations to the given cmy tuple
  (numbers between 0 and 1).

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@cmy@fill\marg{cyan}\marg{magenta}\marg{yellow}}
  Sets the color used for filling operations to the given cmy tuple
  (numbers between 0 and 1).

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@gray\marg{black}}
  Sets the color used for stroking and filling operations to the given
  black value, where 0 means black and 1 means white.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@gray@stroke\marg{black}}
  Sets the color used for stroking operations to the given black value,
  where 0 means black and 1 means white.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@gray@fill\marg{black}}
  Sets the color used for filling operations to the given black value,
  where 0 means black and 1 means white.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@reset}
  This command will be called when the |\color| command is used. It
  should purge any internal settings of stroking and filling
  color. After this call, till the next use of a command like
  |\pgfsys@color@rgb@fill|, the current color installed by the
  |\color| command should be used.

  If the \TeX-if |\pgfsys@color@reset@inorder| is set to true, this
  command may ``assume'' that any call to a color command that sets
  the fill or stroke color came ``before'' the call to this command
  and may try to optimize the output accordingly.

  An example of an incorrect ``out of order'' call would be using
  |\pgfsys@color@reset| at the beginning of a box that is constructed
  using |\setbox|. Then, when the box is constructed, no special fill
  or stroke color might be in force. However, when the box is later on
  inserted at some point, a special fill color might already have been
  set. In this case, this command is not guaranteed to reset the color
  correctly.
\end{command}

\begin{command}{\pgfsys@color@reset@inordertrue}
  Sets the optimized ``in order'' version of the color resetting. This
  is the default.
\end{command}

\begin{command}{\pgfsys@color@reset@inorderfalse}
  Switches off the optimized color resetting.
\end{command}

\begin{command}{\pgfsys@color@unstacked\marg{\LaTeX\ color}}
  This slightly obscure command causes the color stack to be
  tricked. When called, this command should set the current color to
  \meta{\LaTeX\ color} without causing any change in the color stack.

  \example |\pgfsys@color@unstacked{red}|
\end{command}




\subsection{Pattern System Commands}


\begin{command}{\pgfsys@declarepattern
    \marg{name}\marg{$x_1$}\marg{$y_1$}\marg{$x_2$}\marg{$y_2$}
    \marg{$x$ step}\marg{$y$ step}\marg{code}\marg{flag}}
  This command declares a new colored or uncolored pattern, depending
  on whether \meta{flag} is |0|, which means uncolored, or |1|, which
  means colored. Uncolored patterns have no inherent color, the color
  is provided when they are set. Colored patters have an inherent
  color.

  The \meta{name} is a name for later use when the pattern is to be
  shown. The pairs $(x_1,y_1)$ and $(x_2,y_2)$ must describe a
  bounding box of the pattern \meta{code}.

  The tiling step of the pattern is given by \meta{$x$ step} and
  \meta{$y$ step}.

  \example
\begin{codeexample}[code only]
\pgfsys@declarepattern{hori}{-.5pt}{0pt}{.5pt}{3pt}{3pt}{3pt}
{\pgfsys@moveto{0pt}{0pt}\pgfsys@lineto{0pt}{3pt}\pgfsys@stroke}
{0}
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@setpatternuncolored\marg{name}\marg{red}\marg{green}\marg{blue}}
  Sets the fill color to the pattern named \meta{name}. This pattern
  must previously have been declared with \meta{flag} set to |0|. The
  color of the pattern is given in the parameters \meta{red},
  \meta{green}, and \meta{blue} in the usual way.

  The fill color ``pattern''  will persist till the next color command
  that modifies the fill color.
\end{command}

\begin{command}{\pgfsys@setpatterncolored\marg{name}}
  Sets the fill color to the pattern named \meta{name}. This pattern
  must have been declared with the |1| flag.
\end{command}




\subsection{Image System Commands}

The system layer provides some commands for image inclusion.

\begin{command}{\pgfsys@imagesuffixlist}
  This macro should expand to a list of suffixes, separated by `:',
  that will be tried when searching for an image.

  \example |\def\pgfsys@imagesuffixlist{eps:epsi:ps}|
\end{command}


\begin{command}{\pgfsys@defineimage}
  Called, when an image should be defined.

  This command does not take any parameters. Instead, certain macros
  will be preinstalled with appropriate values when this command is
  invoked. These are:

  \begin{itemize}
  \item\declare{|\pgf@filename|}
    File name of the image to be defined.

  \item\declare{|\pgf@imagewidth|}
    Will be set to the desired (scaled) width of the image.

  \item\declare{|\pgf@imageheight|}
    Will be set to the desired (scaled) height of the image.

    If this macro and also the height macro are empty, the image
    should have its ``natural'' size.

    If only one of them is specified, the undefined value the
    image is scaled so that the aspect ratio is kept.

    If both are set, the image is scaled in both directions
    independently, possibly changing the aspect ratio.
  \end{itemize}

  The following macros presumable mostly make sense for drivers that
  can handle \pdf:

  \begin{itemize}
  \item \declare{|\pgf@imagepage|}
    The desired page number to be extracted from a multi-page
    ``image.''

  \item\declare{|\pgf@imagemask|}
    If set, it will be set to |/SMask x 0 R| where |x| is the \pdf\
    object number of a soft mask to be applied to the image.

  \item\declare{|\pgf@imageinterpolate|}
    If set, it will be set to |/Interpolate true| or
    |/Interpolate false|, indicating whether the image should be
    interpolated in \pdf.
  \end{itemize}

  The command should now set up the macro |\pgf@image| such that calling
  this macro will result in typesetting the image. Thus, |\pgf@image| is
  the ``return value'' of the command.

  This command has a default implementation and need not be
  implemented by a driver file.
\end{command}



\subsection{Shading System Commands}


\begin{command}{\pgfsys@horishading\marg{name}\marg{height}\marg{specification}}
  Declares a horizontal shading for later use. The effect of this
  command should be the definition of a macro called |\@pgfshading|\meta{name}|!|
  (or |\csname @pdfshading|\meta{name}|!\endcsname|, to be
  precise). When invoked, this new macro should insert a shading at
  the current position.

  \meta{name} is the name of the shading, which is also used in the
  output macro name. \meta{height} is the height of the shading and
  must be given as a TeX dimension like |2cm| or
  |10pt|. \meta{specification} is a shading color
  specification as specified in Section~\ref{section-shadings}. The
  shading specification implicitly fixes the width of the shading.

  When |\@pgfshading|\meta{name}|!| is invoked, it should insert a box
  of height \meta{height} and the width implicit in the shading
  declaration.
\end{command}


\begin{command}{\pgfsys@vertshading\marg{name}\marg{width}\marg{specification}}
  Like the horizontal version, only for vertical shadings. This time,
  the height of the shading is implicit in \meta{specification} and
  the width is given as \meta{width}.
\end{command}

\begin{command}{\pgfsys@radialshading\marg{name}\marg{starting point}\marg{specification}}
  Declares a radial shading. Like the previous macros, this command
  should set up the macro |\@pgfshading|\meta{name}|!|, which upon
  invocation should insert a radial shading whose size is implicit in
  \meta{specification}.

  The parameter \meta{starting point} is a \pgfname\ point
  specifying the inner starting point of the shading.
\end{command}


\begin{command}{\pgfsys@functionalshading\marg{name}\marg{lower left
      corner}\meta{upper right corner}\marg{type 4 function}}
 Declares a shading using a PostScript-like function that provides a
 color for each point. Like the previous macros, this command
 should set up the macro |\@pgfshading|\meta{name}|!| so that it will
 produce a box containing the desired shading.

 Parameter \meta{name} is the name of the shading. Parameter
 \meta{type 4 function} is a
 Postscript-like function (type 4 function of the PDF specification)
 as described in Section 3.9.4 of the PDF specification version 1.7.
 Parameters \meta{lower left corner} and \meta{upper right corner} are
 \pgfname\ points that specifies the lower left and upper right
 corners of the shading, respectively.

 When \meta{type 4 function} is evaluated, the coordinate of the current
 point will be on the (virtual) PostScript stack in bp units. After
 the function has been evaluated, the stack should consist of three
 numbers (not integers! -- the Apple PDF renderer is broken in this
 regard, so add cvrs at the end if needed) that represent the red,
 green, and blue components of the color.

 A buggy function will result is \emph{totally unpredictable chaos} during
 rendering.
\end{command}



\subsection{Transparency System Commands}

\begin{command}{\pgfsys@opacity\marg{value}}
  Sets the opacity of all operations, treating stroking and filling as
  a transparency group. Some drivers support this operations, others
  do not and set the fill and stroke individually. This difference can
  only be seen when a path is stroked and filled at the same time:
  When the drawing and fill opacities are set individually, the effect
  of filling and drawing a path at the same time is the same as first
  filling the path and then drawing it. On the other, if the opacity
  is set using this command, the effect should rather be that same as
  first filling and then drawing the path without any opacity in an
  off-screen area and then copying the result to the target area with
  a homogeneous opacity of \meta{value}.

  Since \textsc{pdf} does not support this form of opacity, this
  command is only present on the system layer and not supported in the
  basic layer.
\end{command}

\begin{command}{\pgfsys@stroke@opacity\marg{value}}
  Sets the opacity of stroking operations.
\end{command}

\begin{command}{\pgfsys@fill@opacity\marg{value}}
  Sets the opacity of filling operations.
\end{command}

\begin{command}{\pgfsys@blend@mode\marg{value}}
  Sets the blend mode, see Section 7.2.4 of the \textsc{pdf}
  Specification, Version 1.7.
\end{command}

\begin{command}{\pgfsys@transparencygroupfrombox\marg{box}}
  This takes a \TeX\ box and converts it into a transparency
  group. This means that any transparency settings apply to the box as
  a whole. For instance, if a box contains two overlapping black
  circles and you draw the box and, thus, the two circles normally
  with 50\% transparency, then the overlap will be darker than the
  rest. By comparison, if the circles are part of a transparency
  group, the overlap will get the same color as the rest.
\end{command}

A transparency group can be \emph{isolated} and/or a \emph{knockout}
group (see Sections 7.3.4 and 7.3.5 of the \textsc{pdf}
Specification Version 1.7). Which of these is the case is dictated
by the current settings of the following two ifs, which must be set
before the above command is called:
  
{\let\ifpgfsys@transparency@group@isolated=\relax
\begin{command}{\ifpgfsys@transparency@group@isolated}
  Determines whether a transparency group should be isolated. 
\end{command}
}

{\let\ifpgfsys@transparency@group@knockout=\relax
\begin{command}{\ifpgfsys@transparency@group@knockout}
  Determines whether a transparency group is a knockout group or not. 
\end{command}
}


  
\begin{command}{\pgfsys@fadingfrombox\marg{name}\marg{box}}
  Declares the fading \meta{name}. The \meta{box} is a \TeX-box. Its
  content's luminosity determines the opacity of the resulting
  fading. This means that the lighter a pixel inside the box, the more
  opaque the fading will be at this position.
\end{command}

\begin{command}{\pgfsys@usefading\meta{name}\marg{a}\marg{b}\marg{c}\marg{d}\marg{e}\marg{f}}
  Installs a previously declared fading \meta{name} in the current
  graphics state. Afterwards, all drawings will be masked by the
  fading. The fading should be centered on the origin and have its
  original size, except that the parameters \meta{a} to \meta{f}
  specify a transformation matrix that should be applied additionally
  to the fading before it is installed. The transformation should not
  apply to the following graphics, however.
\end{command}


\begin{command}{\pgfsys@definemask}
  This command declares a fading (known as a soft mask in this
  context) based on an image and for usage with images. It
  works similar to |\pgfsys@defineimage|: Certain macros are set when
  the command is called. The result should be to set the macro
  |\pgf@mask| to a pdf object count that can subsequently be used as a
  transparency mask. The following macros will be set when this command is
  invoked:

  \begin{itemize}
  \item \declare{|\pgf@filename|}
    File name of the mask to be defined.

  \item \declare{|\pgf@maskmatte|}
    The so-called matte of the mask (see the \pdf\ documentation for
    details). The matte is a color specification consisting of 1, 3 or
    4 numbers between 0 and 1. The number of numbers depends on the
    number of color channels in the image (not in the mask!). It will
    be assumed that the image has been preblended with this color.
  \end{itemize}
\end{command}


\subsection{Animation Commands}

\subsubsection{Introduction to the Animation System Layer}

In conjunction with the right output format (namely
\textsc{svg}), you can specify that certain parts of you graphics can
be animated. For this, there are a large number of commands that
cover, currently, what \textsc{svg 1.1} can do regarding animations.
For a detailed introduction to animations, please see
Section~\ref{section-animations}; the current section assumes that you
are familiar with the concepts explained there.

The system layer loosely follows the philosophy of \textsc{svg}'s
animation system: An animation always concerns an \emph{attribute} of a
\emph{graphic object} and is configured by \emph{keys}. For instance,
you might animate the ``opacity'' attribute of a specific graphic
scope or of a specific path or of a specific text; and the keys
specify that this animation should last for 3 seconds and vary the
opacity from $0$ to~$1$. The three parts of an animation, namely the
\emph{attribute}, the \emph{graphic object}, and the \emph{keys}, are
specified in quite different ways:

\begin{enumerate}
\item For each \emph{attribute} there is a system layer command
  |\pgfsys@animate...|. For instance, the command |\pgfsys@animateopacity|
  animates the opacity attribute of some graphic object, the command
  |\pgfsys@animatelinewidth| animates the line width, and so on.
\item The \emph{graphic object} whose attribute is to be animated is
  \emph{always} specified by naming the ID of the graphic object
  \emph{before} this object is created, see
  Section~\ref{section-sys-id}. (However, in the context of
  \tikzname, it suffices that the animation is given in the object's
  options since these are executed before the actual object is
  created). 
\item The \emph{keys} are specified by commands starting
  |\pgfsys@animation@...| and have the following effect: They set some
  animation key to a given value \emph{for the current \TeX\ scope,}
  but do not create any animations. Rather, when one of the commands
  |\pgfsys@animate...| is used, a snapshot of the current values of
  all animation keys is taken and added to this animation of the
  attribute.

  When you set an animation key to a value, this will usually replace
  the value previously stored for the key (all keys are empty by
  default at the beginning). For some keys, however, the values
  assigned to the key \emph{accumulate} in the key such as for the
  ``values'' key since an animation typically needs several
  values. Still, such accumulating keys, too, revert to their previous
  (accumulated) value at the end of the current \TeX\ scope. 

  Note that animation keys are local to \TeX\ scopes, not graphics
  scopes; indeed, they have little to do with the settings of the
  graphics scope. 
\end{enumerate}

A typical example of how all of this works is the following:
\begin{codeexample}[code only]
\pgfsys@animation@dur{5} % Both of the following animations take 5s
{
  \pgfsys@animation@whom{\someid}{}% The id of a later object
  \pgfsys@animation@offset{10}{begin}% Begin after 5s ...
  \pgfsys@animation@event{}{click}{1}{begin}% ... or 1s after a click
  \pgfsys@animation@scalar{0.5}{to}% Animate the attribute is 0.5 ...
  \pgfsys@animatefillopacity% ... and the attribute is the fill opacity
}
{
  \pgfsys@animation@whom{\someid}{}% The id of a later object
  \pgfsys@animation@offset{0}{begin}% Begin right away ...
  \pgfsys@animation@dimension{2pt}{by}% Advance the attribute by 2pt ...
  \pgfsys@animatelinewidth% ... and the attribute is the line width
}
\end{codeexample}



\iffalse

\subsubsection{Commands for Animating an Attribute: Color, Opacity, Visibility}

The commands from this and the next sections specify that some
attribute should be animated. We start with rather basic animation
attributes for color, visibility, and opacity.

Note that when several of these commands are used to animate the
\emph{same} attribute of the \emph{same} target graphic object at the
\emph{same} time, the last one ``wins.'' For instance, when you use
|\pgfsys@animateopacity| to animate the opacity to |0.5| at a certain
time for a path and then use the same command again to animate the
opacity to |0.25| of the same path at the same moment, the opacity
will be set to |0.25| (and not |0.5| and also not |0.125| as some sort
of combined effect). Note that for animations of the transformation
matrix the behaviour is different. 

\begin{command}{\pgfsys@animateopacity}
  Adds an animation of the opacity to the graphic object specified
  using |\pgfsys@animation@whom|. This is a bit different from animating
  the fill and stroke opacities  individually: Paths are treated as
  transparency groups for this key. Typically, ``this is what you
  want.''
  
  Specify values with |\pgfsys@animation@scalar|.

\begin{codeexample}[width=2cm]
\tikz[fill=blue!25, draw=blue, ultra thick] {
  \pgfidrefnextuse{\nodeid}{node} \pgfsys@animation@whom{\nodeid}{}
  \pgfsys@animation@dur{2} \pgfsys@animation@event{}{}{click}{}{begin}
  \pgfsys@animation@scalar{0}{to}
  \pgfsys@animateopacity
  \node [circle, fill, draw, align=center] (node) {Click \\ here}; }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animatefillopacity}
  Adds an animation of only the opacity of fill operations.
  
  Specify values with |\pgfsys@animation@scalar|.

\begin{codeexample}[width=2cm]
\tikz[fill=blue!25, draw=blue, ultra thick] {
  \pgfidrefnextuse{\nodeid}{node} \pgfsys@animation@whom{\nodeid}{}
  \pgfsys@animation@dur{2} \pgfsys@animation@event{}{}{click}{}{begin}
  \pgfsys@animation@scalar{0}{to}
  \pgfsys@animatefillopacity 
  \node [circle, fill, draw, align=center] (node) {Click \\ here}; }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animatestrokeopacity}
  Adds an animation of only the opacity of draw (stroke) operations.
  
  Specify values with |\pgfsys@animation@scalar|.
  
\begin{codeexample}[width=2cm]
\tikz[fill=blue!25, draw=blue, ultra thick] {
  \pgfidrefnextuse{\nodeid}{node} \pgfsys@animation@whom{\nodeid}{}
  \pgfsys@animation@dur{2} \pgfsys@animation@event{}{}{click}{}{begin}
  \pgfsys@animation@scalar{0}{to}
  \pgfsys@animatestrokeopacity 
  \node [circle, fill, draw, align=center] (node) {Click \\ here}; }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animatevisibility}
  Adds an animation of the ``visiblity''.
  
  Specify values with |\pgfsys@animation@text|. However, only two values are allowed:
  |visible| and |hidden|.
\begin{codeexample}[width=2cm]
\tikz[fill=blue!25, draw=blue, ultra thick] {
  \pgfidrefnextuse{\nodeid}{node} \pgfsys@animation@whom{\nodeid}{}
  \pgfsys@animation@dur{2} \pgfsys@animation@event{}{}{click}{}{begin}
  \pgfsys@animation@text{hidden}{to}
  \pgfsys@animatevisibility 
  \node [circle, fill, draw, align=center] (node) {Click \\ here}; }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animatestrokecolor}
  Adds an animation of the stroke color.

  Specify values with |\pgfsys@animation@color@rgb| and friends.
\begin{codeexample}[width=2cm]
\tikz[fill=blue!25, draw=blue, ultra thick] {
  \pgfidrefnextuse{\nodeid}{node} \pgfsys@animation@whom{\nodeid}{}
  \pgfsys@animation@dur{2} \pgfsys@animation@event{}{}{click}{}{begin}
  \pgfsys@animation@color@rgb{1}{0}{0}{to}
  \pgfsys@animatestrokecolor 
  \node [circle, fill, draw, align=center] (node) {Click \\ here}; }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animatefillcolor}
  Adds an animation of the fill color.
  
  Specify values with |\pgfsys@animation@color@rgb| and friends.
\begin{codeexample}[width=2cm]
\tikz[fill=blue!25, draw=blue, ultra thick] {
  \pgfidrefnextuse{\nodeid}{node} \pgfsys@animation@whom{\nodeid}{}
  \pgfsys@animation@dur{2} \pgfsys@animation@event{}{}{click}{}{begin}
  \pgfsys@animation@color@rgb{1}{0}{0}{to}
  \pgfsys@animatefillcolor 
  \node [circle, fill, draw, align=center] (node) {Click \\ here}; }
\end{codeexample}
\end{command}


\subsubsection{Commands for Animating an Attribute: Paths and their Rendering}

The following attributes influence paths and how they are rendered.

\begin{command}{\pgfsys@animatepath}
  Adds an animation of the path itself. That means that the path will
  morph its form from one path to another. When morphing a path, all
  ``values,'' which are the paths, must consist of the  \emph{exact
    same} path construction commands; they may only differ with
  respect to the numbers used in these descriptions.
  
  Specify values with |\pgfsys@animation@path|.
\begin{codeexample}[width=2.3cm]
\tikz {
  \pgfidrefnextuse{\pathid}{my path} \pgfsys@animation@whom{\pathid}{}
  \pgfsys@animation@dur{2} \pgfsys@animation@event{\pathid}{}{click}{}{begin}
  \pgfsys@animation@whom{\pathid}{-path}
  \pgfsys@animation@path{% Start path
    \pgfpathmoveto{\pgfpointxy{0}{0}} \pgfpathlineto{\pgfpointxy{1}{1}}
    \pgfpathlineto{\pgfpointxy{2}{0}} }{values}
  \pgfsys@animation@path{% Mid path
    \pgfpathmoveto{\pgfpointxy{0}{1}} \pgfpathlineto{\pgfpointxy{2}{1}}
    \pgfpathlineto{\pgfpointxy{0}{0}} }{values}
  \pgfsys@animation@path{% End path
    \pgfpathmoveto{\pgfpointxy{1}{1}} \pgfpathlineto{\pgfpointxy{1}{0}}
    \pgfpathlineto{\pgfpointxy{2}{0}}}{values}
  \pgfsys@animatepath
  \filldraw [ultra thick,draw=blue,fill=blue!20] (0,0) -- (1,1) -- (2,0) [name=my path];
  \node [above,font=\scriptsize] at (1,0) {Click here};
}
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animatelinewidth}
  Adds an animation of the line width.
  
  Specify values with |\pgfsys@animation@dimension|.
\begin{codeexample}[width=2cm]
\tikz[fill=blue!25, draw=blue, ultra thick] {
  \pgfidrefnextuse{\nodeid}{node} \pgfsys@animation@whom{\nodeid}{}
  \pgfsys@animation@dur{2} \pgfsys@animation@event{}{}{click}{}{begin}
  \pgfsys@animation@scalar{10pt}{to}
  \pgfsys@animatelinewidth
  \node [circle, fill, draw, align=center] (node) {Click \\ here}; }
\end{codeexample}
\end{command}


\subsubsection{Commands for Animating an Attribute: Transformations  and Views}

The commands in this section allow you to animate the canvas
transformation matrix of a scope. However, there is one command that
needs to be explained first.

\begin{command}{\pgfsys@animation@canvas@transform\marg{pre}\marg{post}}
  To be written...

\begin{codeexample}[]
\pgfsys@animation@canvas@transform%
  {{\pgflowlevelsynccm}}{\pgftransforminvert\pgflowlevelsynccm}    
\tikz[fill=blue!25, draw=blue, ultra thick, rotate=30] {
  \draw [help lines] (-1.5,-1.5) grid (1.5,1.5);
  \pgfidrefnextuse{\nodeid}{node a} \pgfsys@animation@whom{\nodeid}{}
  \pgfsys@animation@dur{2} \pgfsys@animation@event{}{}{click}{}{begin}
  \pgfsys@animation@translate{0cm}{1cm}{to} 
  \pgfsys@animatetranslate % Move node a "up"
  \pgfidrefnextuse{\nodeid}{node b} \pgfsys@animation@whom{\nodeid}{}
  \pgfsys@animatetranslate % Also move node b "up"
  \node [circle, fill, draw, align=center] at (0,1)  (node a)
    {Click \\ here}; 
  \node [circle, fill, draw, align=center, transform shape] at (0,-1) (node b)
    {Click \\ here}; }
\end{codeexample}
\end{command}


\begin{command}{\pgfsys@animatetranslate}
  Adds an (additional) translate animation. Effectively, this causes
  the group to be shifted to different positions.
  
  Specify values with |\pgfsys@animation@translate|. 
\begin{codeexample}[width=2cm]
\tikz[fill=blue!25, draw=blue, ultra thick] {
  \pgfidrefnextuse{\nodeid}{node} \pgfsys@animation@whom{\nodeid}{}
  \pgfsys@animation@dur{2} \pgfsys@animation@event{}{}{click}{}{begin}
  \pgfsys@animation@translate{1cm}{1cm}{to}
  \pgfsys@animatetranslate 
  \node [circle, fill, draw, align=center] (node) {Click \\ here}; }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animatescale}
  Adds an animation of the scaling relative to the origin. This causes
  a scaling of the canvas, including fonts and line widths.
  
  Specify values with |\pgfsys@animation@scale|.
\begin{codeexample}[width=2cm]
\tikz[fill=blue!25, draw=blue, ultra thick] {
  \pgfidrefnextuse{\nodeid}{node} \pgfsys@animation@whom{\nodeid}{}
  \pgfsys@animation@dur{2} \pgfsys@animation@event{}{}{click}{}{begin}
  \pgfsys@animation@scale{1}{1}{from}
  \pgfsys@animation@scale{0.5}{2}{to}
  \pgfsys@animatescale
  \node [circle, fill, draw, align=center] (node) {Click \\ here}; }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animaterotate}
  Adds a rotation animation around the origin.
  
  Specify values with |\pgfsys@animation@scalar|.
\begin{codeexample}[width=2cm]
\tikz[fill=blue!25, draw=blue, ultra thick] {
  \pgfidrefnextuse{\nodeid}{node} \pgfsys@animation@whom{\nodeid}{}
  \pgfsys@animation@dur{2} \pgfsys@animation@event{}{}{click}{}{begin}
  \pgfsys@animation@scalar{90}{to}
  \pgfsys@animaterotate
  \node [circle, fill, draw, align=center] (node) {Click \\ here}; }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animateskewx}
  Adds an animation of a skewing of the canvas along the
  $x$-axis. Unlike the |slant| options of \tikzname, the skew is given
  in degrees.
  
  Specify values with |\pgfsys@animation@scalar|.
\begin{codeexample}[width=2cm]
\tikz[fill=blue!25, draw=blue, ultra thick] {
  \pgfidrefnextuse{\nodeid}{node} \pgfsys@animation@whom{\nodeid}{}
  \pgfsys@animation@dur{2} \pgfsys@animation@event{}{}{click}{}{begin}
  \pgfsys@animation@scalar{45}{to}
  \pgfsys@animateskewx 
  \node [circle, fill, draw, align=center] (node) {Click \\ here}; }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animateskewy}
  Adds an animation of a skewing of the canvas along the $y$-axis.
  
  Specify values with |\pgfsys@animation@scalar|.
\end{command}

\begin{command}{\pgfsys@animatemotion}
  Works a bit like |\pgfsys@animation@translate|: It also adds an
  animated shift transformation of the canvas. However, itstead of
  specifying some shift coordinates as values, you now specify a whole
  path (which may include curves) and an animated translate
  transformation for the different points on this path get installed.
  Furthermore, if you use |\pgfsys@animation@rotatealong|, an
  additional adaptive rotation transformation will be added so that
  the animated graphic scope ``points along'' the path.
  
  Specify values with |\pgfsys@animation@movealong|.
\begin{codeexample}[width=2cm]
\tikz[fill=blue!25, draw=blue, ultra thick] {
  \pgfidrefnextuse{\nodeid}{node} \pgfsys@animation@whom{\nodeid}{}
  \pgfsys@animation@dur{2} \pgfsys@animation@event{}{}{click}{}{begin}
  \pgfsys@animation@movealong{%
    \pgf@relevantforpicturesizefalse
    \pgfpathmoveto{\pgfpointxy{0}{0}} \pgfpathlineto{\pgfpointxy{0}{1}}
    \pgfpatharc{180}{90}{1cm}}
  \pgfsys@animatemotion 
  \node [circle, fill, draw, align=center] (node) {Click \\ here}; }
\end{codeexample}
\begin{codeexample}[width=2cm]
\tikz[fill=blue!25, draw=blue, ultra thick] {
  \pgfidrefnextuse{\nodeid}{node} \pgfsys@animation@whom{\nodeid}{}
  \pgfsys@animation@dur{2} \pgfsys@animation@event{}{}{click}{}{begin}
  \pgfsys@animation@rotatealong
  \pgfsys@animation@movealong{%
    \pgf@relevantforpicturesizefalse
    \pgfpathmoveto{\pgfpointxy{0}{0}} \pgfpathlineto{\pgfpointxy{0}{1}}
    \pgfpatharc{180}{90}{1cm}}
  \pgfsys@animatemotion 
  \node [circle, fill, draw, align=center] (node) {Click \\ here}; }
\end{codeexample}
\end{command}


\begin{command}{\pgfsys@animateviewbox}
  Adds an animation of the view box. The graphic scope to which this
  animation is added must have been created using
  |\pgfsys@viewboxmeet| or |\pgfsys@viewboxslice|; adding it to other
  scopes has no effect. Note   that this command does \emph{not}
  change or animate the scope's transformation matrix -- it only animates the
  ``what we see through the view box.''
  
  Specify values with |\pgfsys@animation@viewbox|.
\begin{codeexample}[width=2.3cm]
\tikz[fill=blue!25, draw=blue] {
  \pgfidrefnextuse{\nodeid}{node} \pgfsys@animation@whom{\nodeid}{}
  \pgfsys@animation@dur{2} \pgfsys@animation@event{}{}{click}{}{begin}
  \pgfidrefnextuse{\viewid}{my view} \pgfsys@animation@whom{\viewid}{view}
  \pgfsys@animation@viewbox{-5mm}{-5mm}{7mm}{8mm}{to}%
  \pgfsys@animateviewbox 
  \draw (-1,-1) rectangle (1,1);  
  \begin{scope}[meet={view (-1,-1) (1,1)}, name=my view] 
    \node (node) [circle, fill, draw, align=center, ultra thick] {Click \\ here};
    \draw (-5mm,-5mm) rectangle (7mm,8mm);  
  \end{scope} }
\end{codeexample}
\end{command}


\subsubsection{Commands for Specifying the Target Object}

\begin{command}{\pgfsys@animation@whom\marg{id}\marg{type}}
  Sets the target of the animation. The \marg{id} must previously have
  been created using |\pgfsys@new@id|, \marg{type} must be a type (the
  empty type is also allowed). See Section~\ref{section-sys-id} for
  details on ids and types.
\end{command}


\subsubsection{Commands for Specifying Timing: Duration and Repeats}

\begin{command}{\pgfsys@animation@dur\marg{seconds}}
  Defines the duration of the animation in seconds.
\begin{codeexample}[width=3.5cm]
\def\showclock{
  \scoped [name=clock,fill=blue!50,shift={(1.25,-1.5)}] {
    \fill circle[radius=9mm];
    \foreach \s in {0,5,...,55} {
      \node [font=\tiny] at (90-\s*6:1.1cm)[] {\s s};
      \draw [white,very thin] (0,0) -- (90-\s*6:9mm); }
    \node [below,font=\small] {Click here};
    \fill [black] (-2pt,0pt) -- (90:0.9cm) -- (2pt,0pt) -- (0pt,-2pt) -- cycle
      [animate={begin on={click,of=clock}, 60s,
        max duration=10s, rotate={360...0}}]; }
  \pgfidrefprevuseornext{\clockid}{clock} }
\def\showtick{ 
  \foreach \i in {0,...,5} \draw (\i*.5,-1mm) -- ++(0,2mm) node [above] {\i}; }
\tikz { \showclock
        \showtick
        \pgfidrefnextuse{\pathid}{path} \pgfsys@animation@whom{\pathid}{}
        \pgfsys@animation@event{\clockid}{}{click}{}{begin}
        \pgfsys@animation@dur{5}
        \pgfsys@animation@translate{0pt}{0pt}{from}
        \pgfsys@animation@translate{25mm}{0pt}{to}
        \pgfsys@animatetranslate 
        \fill [name=path, red] circle[radius=0.75mm]; }
\end{codeexample}
\end{command}

\def\showclock{
  \scoped [name=clock,fill=blue!50,shift={(1.25,-1.5)}] {
    \fill circle[radius=9mm];
    \foreach \s in {0,5,...,55} {
      \node [font=\tiny] at (90-\s*6:1.1cm)[] {\s s};
      \draw [white,very thin] (0,0) -- (90-\s*6:9mm); }
    \node [below,font=\small] {Click here};
    \fill [black] (-2pt,0pt) -- (90:0.9cm) -- (2pt,0pt) -- (0pt,-2pt) -- cycle
      [animate={begin on={click,of=clock}, 60s,
        max duration=10s, rotate={360...0}}]; }
  \pgfidrefprevuseornext{\clockid}{clock} }
\def\showtick{ 
  \foreach \i in {0,...,5} \draw (\i*.5,-1mm) -- ++(0,2mm) node [above] {\i}; }

\begin{command}{\pgfsys@animation@min\marg{seconds}}
  Defines the minimum duration of the animation in seconds. This is
  relevant in the context of repeats, see the \textsc{svg}
  specification for details.
\begin{codeexample}[width=3.5cm]
\tikz { \showclock
        \showtick
        \pgfidrefnextuse{\pathid}{path} \pgfsys@animation@whom{\pathid}{}
        \pgfsys@animation@event{\clockid}{}{click}{}{begin}
        \pgfsys@animation@dur{2.5}
        \pgfsys@animation@min{5}
        \pgfsys@animation@translate{0pt}{0pt}{from}
        \pgfsys@animation@translate{25mm}{0pt}{to}
        \pgfsys@animatetranslate 
        \fill [name=path, red] circle[radius=0.75mm]; }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@max\marg{seconds}}
  Defines the maximum duration of the animation in seconds. Note that
  if the duration is also set, this results in a ``cut off'' of the
  animation if the maximum duration is smaller.
\begin{codeexample}[width=3.5cm]
\tikz { \showclock
        \showtick
        \pgfidrefnextuse{\pathid}{path} \pgfsys@animation@whom{\pathid}{}
        \pgfsys@animation@event{\clockid}{}{click}{}{begin}
        \pgfsys@animation@dur{5}
        \pgfsys@animation@max{2.5}
        \pgfsys@animation@translate{0pt}{0pt}{from}
        \pgfsys@animation@translate{25mm}{0pt}{to}
        \pgfsys@animatetranslate 
        \fill [name=path, red] circle[radius=0.75mm]; }
\end{codeexample}
\end{command}


\begin{command}{\pgfsys@animation@repeat\marg{number of times}}
  Specifies that the animation should repeat the specified
  \meta{number of times}, which may be a fractional number.
\begin{codeexample}[width=3.5cm]
\tikz { \showclock
        \showtick
        \pgfidrefnextuse{\pathid}{path} \pgfsys@animation@whom{\pathid}{}
        \pgfsys@animation@event{\clockid}{}{click}{}{begin}
        \pgfsys@animation@dur{3}
        \pgfsys@animation@repeat{2.5} % 3 x 2.5s = 7.5s in total
        \pgfsys@animation@translate{0pt}{0pt}{from}
        \pgfsys@animation@translate{15mm}{0pt}{to}
        \pgfsys@animatetranslate 
        \fill [name=path, red] circle[radius=0.75mm]; }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@repeat@indefinite}
  Specifies that the animation should repeat indefinitely.
\begin{codeexample}[width=3.5cm]
\tikz { \showclock
        \showtick
        \pgfidrefnextuse{\pathid}{path} \pgfsys@animation@whom{\pathid}{}
        \pgfsys@animation@event{\clockid}{}{click}{}{begin}
        \pgfsys@animation@dur{3}
        \pgfsys@animation@repeat@indefinite
        \pgfsys@animation@translate{0pt}{0pt}{from}
        \pgfsys@animation@translate{15mm}{0pt}{to}
        \pgfsys@animatetranslate 
        \fill [name=path, red] circle[radius=0.75mm]; }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@repeat@dur\meta{seconds}}
  Specifies that the animation should repeat until \meta{seconds} have
  elapsed. 
\begin{codeexample}[width=3.5cm]
\tikz { \showclock
        \showtick
        \pgfidrefnextuse{\pathid}{path} \pgfsys@animation@whom{\pathid}{}
        \pgfsys@animation@event{\clockid}{}{click}{}{begin}
        \pgfsys@animation@dur{3}
        \pgfsys@animation@repeat@dur{7}
        \pgfsys@animation@translate{0pt}{0pt}{from}
        \pgfsys@animation@translate{15mm}{0pt}{to}
        \pgfsys@animatetranslate 
        \fill [name=path, red] circle[radius=0.75mm]; }
\end{codeexample}
\end{command}



\subsubsection{Commands for Specifying Timing: Key Times and Time Splines}

\begin{command}{\pgfsys@animation@keytime\marg{fraction}}
  To be written\dots
% % \marg{1} must be a number. The semantics is as in SVS's
% % keyTimes. Accumulates. 
% % 
% % Example:
% % \pgfsys@animation@keytime{0}
% % \pgfsys@animation@keytime{0.1}
% % \pgfsys@animation@keytime{0.5}
% % \pgfsys@animation@keytime{1}
\end{command}

\begin{command}{\pgfsys@animation@keyprogress\marg{1}{}}
  To be written\dots
% % \marg{1} must be a numberd. The semantics is as in SVS's
% % keyPoints. Accumulates. 
% % 
% % Example:
% % \pgfsys@animation@keyprogress{0}
% % \pgfsys@animation@keyprogress{0.1}
% % \pgfsys@animation@keyprogress{0.5}
% % \pgfsys@animation@keyprogress{1}
\end{command}

\begin{command}{\pgfsys@animation@keysplinecontrol\marg{1}\marg{2}\marg{3}\marg{4}{}}
  To be written\dots
% % The four control values of a spline. The semantics is as in SVS's
% % keySplines. Accumulates.
% % 
% % Example:
% %
% % % control points between first and second key time
% % \pgfsys@animation@keysplinecontrol{.5}{0}{.5}{1}
% % % control points between second and thrid key time
% % \pgfsys@animation@keysplinecontrol{.5}{1}{1}{.5}
\end{command}



\subsubsection{Commands for Specifying Timing: Beginning and Ending}


\begin{command}{\pgfsys@animation@offset\marg{1}\marg{2}{}}
  To be written\dots
% % \marg{1} must be a value in seconds, \marg{2} is the target "begin" or "end" to
% % which this offset is appended.
\end{command}

\begin{command}{\pgfsys@animation@syncbegin\marg{1}\marg{2}\marg{3}\marg{4}{}}
  To be written\dots
% % \marg{1} is the id of a sync base (obtained by
% % \pgfsys@new@id), \marg{2} is the id type (or empty), \marg{3} is an optional
% % offset, \marg{4} is the target.  
\end{command}

\begin{command}{\pgfsys@animation@syncend\marg{1}\marg{2}\marg{3}\marg{4}{}}
  To be written\dots
% % Like the previous command.
\end{command}

\begin{command}{\pgfsys@animation@event\marg{1}\marg{2}\marg{3}\marg{4}\marg{5}{}}
  To be written\dots
% % \marg{1} is the optional id of another element (obtained by
% % \pgfsys@new@id), \marg{2} is the optional type of the id, \marg{3} is an event
% % name, \marg{4} is an optional offset, \marg{5} is the target.  
\end{command}

\begin{command}{\pgfsys@animation@repeat@event\marg{1}\marg{2}\marg{3}\marg{4}\marg{5}{}}
  To be written\dots
% % \marg{1} is the optional id of another element, \marg{2} is the type, \marg{3} is a
% % repeat count, and \marg{4} is an optional offset, \marg{5} is the target. 
\end{command}

\begin{command}{\pgfsys@animation@accesskey\marg{1}\marg{2}\marg{3}{}}
  To be written\dots
% % \marg{1} is a character, \marg{2} is an optional offset, \marg{3} is the target. 
\end{command}



\subsubsection{Commands for Specifying Timing: Restart Behaviour}

\begin{command}{\pgfsys@animation@restart@always}
  Defines that the animation can be restarted at any time. This is the
  default.
\end{command}

\begin{command}{\pgfsys@animation@restart@never}
  Defines that the animation cannot be restarted once it has run.
\begin{codeexample}[width=3.5cm]
\tikz { \showclock
        \showtick
        \pgfidrefnextuse{\pathid}{path} \pgfsys@animation@whom{\pathid}{}
        \pgfsys@animation@event{\clockid}{}{click}{}{begin}
        \pgfsys@animation@dur{5}
        \pgfsys@animation@restart@never
        \pgfsys@animation@translate{0pt}{0pt}{from}
        \pgfsys@animation@translate{25mm}{0pt}{to}
        \pgfsys@animatetranslate 
        \fill [name=path, red] circle[radius=0.75mm]; }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@restart@whennotactive}
  Defines that the animation cannot be restarted while it is running.
\begin{codeexample}[width=3.5cm]
\tikz { \showclock
        \showtick
        \pgfidrefnextuse{\pathid}{path} \pgfsys@animation@whom{\pathid}{}
        \pgfsys@animation@event{\clockid}{}{click}{}{begin}
        \pgfsys@animation@dur{5}
        \pgfsys@animation@restart@whennotactive
        \pgfsys@animation@translate{0pt}{0pt}{from}
        \pgfsys@animation@translate{25mm}{0pt}{to}
        \pgfsys@animatetranslate 
        \fill [name=path, red] circle[radius=0.75mm]; }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@freezeatend{}}
  When an animation ends, the question is whether the ``effect'' of
  the animation (like changing a color or translating the coordinate
  system) should disappear or ``remain in force.'' Using this key, you
  specify that at the end of the animation the last value of the
  attributes stayes in effect.
\begin{codeexample}[width=3.5cm]
\tikz { \showclock
        \showtick
        \pgfidrefnextuse{\pathid}{path} \pgfsys@animation@whom{\pathid}{}
        \pgfsys@animation@event{\clockid}{}{click}{}{begin}
        \pgfsys@animation@dur{5}
        \pgfsys@animation@freezeatend
        \pgfsys@animation@translate{0pt}{0pt}{from}
        \pgfsys@animation@translate{25mm}{0pt}{to}
        \pgfsys@animatetranslate 
        \fill [name=path, red] circle[radius=0.75mm]; }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@removeatend{}}
  The opposite of |\pgfsys@animation@freezeatend|. This is the default.
\end{command}

\subsubsection{Commands for Specifying Values, Their Accumulation, and
  Their Interpolation}
\label{section-value-types}



% % Accumulation

\begin{command}{\pgfsys@animation@sum{}}
  To be written\dots
% % Corresponds to additive="sum" in SVG
\end{command}

\begin{command}{\pgfsys@animation@replace{}}
  To be written\dots
% % Corresponds to additive="replace" in SVG
\end{command}

\begin{command}{\pgfsys@animation@accumulate{}}
  To be written\dots
% % Corresponds to accumulate="sum" in SVG
\end{command}

\begin{command}{\pgfsys@animation@noaccumulate{}}
  To be written\dots
% % Corresponds to accumulate="none" in SVG
\end{command}


% % Attribute definitions


\begin{command}{\pgfsys@animation@discrete{}}
  To be written\dots
% % Corresponds to calcMode="discrete" in SVG
\end{command}

\begin{command}{\pgfsys@animation@linear{}}
  To be written\dots
% % Corresponds to calcMode="linear" in SVG
\end{command}

\begin{command}{\pgfsys@animation@paced{}}
  To be written\dots
% % Corresponds to calcMode="paced" in SVG
\end{command}

\begin{command}{\pgfsys@animation@spline{}}
  To be written\dots
% % Corresponds to calcMode="spline" in SVG
\end{command}

\begin{command}{\pgfsys@animation@rotatealong{}}
  To be written\dots
% % Applicable only to motion animations. Indicates that the
% % to-be-animated group should be rotated automatically so that it
% % points along the path as time progresses. 
\end{command}

\begin{command}{\pgfsys@animation@norotatealong{}}
  To be written\dots
% % Corresponds to rotate="0"
\end{command}

\begin{command}{\pgfsys@animation@movealong\marg{1}{}}
  To be written\dots
% % Applicable only to motion animations. \marg{1} is a path along which the
% % movement will be done. It is executed and must call \pgfsys@lineto
% % and similar path-construction commands. It should not call other
% % \pgfsys@ commands.
\end{command}

% % Values
\begin{command}{\pgfsys@animation@text\marg{1}\marg{2}{}}
  To be written\dots
% % \marg{1} should be some text. \marg{2} is the key to which this scalar value is
% % added (must be "to", "from", "by" or "values") 
\end{command}

\begin{command}{\pgfsys@animation@scalar\marg{1}\marg{2}{}}
  To be written\dots
% % \marg{1} should be a single value. \marg{2} is the key to which this scalar
% % value is added (must be "to", "from", "by" or "values")
\end{command}

\begin{command}{\pgfsys@animation@dimension\marg{1}\marg{2}{}}
  To be written\dots
% % \marg{1} must be a dimension. \marg{2} is the key to which this value is added.
\end{command}

\begin{command}{\pgfsys@animation@color@rgb\marg{1}\marg{2}\marg{3}\marg{4}{}}
  To be written\dots
% % \marg{1},\marg{2},\marg{3} must be an rgb tuple, \marg{4} is the key to which this is added
\end{command}

\begin{command}{\pgfsys@animation@color@cmyk\marg{1}\marg{2}\marg{3}\marg{4}\marg{5}{}}
  To be written\dots
% % \marg{1},\marg{2},\marg{3},\marg{4} must be an cmyk tuple, \marg{5} is the key to which this is added
\end{command}

\begin{command}{\pgfsys@animation@color@cmy\marg{1}\marg{2}\marg{3}\marg{4}{}}
  To be written\dots
% % \marg{1},\marg{2},\marg{3} must be an cmy tuple, \marg{4} is the key to which this is added
\end{command}

\begin{command}{\pgfsys@animation@color@gray\marg{1}\marg{2}{}}
  To be written\dots
% % \marg{1} must be an rgb tuple, \marg{2} is the key to which this is added
\end{command}

\begin{command}{\pgfsys@animation@path\marg{1}\marg{2}{}}
  To be written\dots
% % \marg{1} must consist of path-construction commands, \marg{2} is the key to
% % which this is added 
\end{command}

\begin{command}{\pgfsys@animation@translate\marg{1}\marg{2}\marg{3}{}}
  To be written\dots
% % \marg{1},\marg{2} must be dimensions, \marg{3} is the key to which this is added
\end{command}

\begin{command}{\pgfsys@animation@scale\marg{1}\marg{2}\marg{3}{}}
  To be written\dots
% % \marg{1},\marg{2} must be dimensionless, \marg{3} is the key to which this is added
\end{command}

\begin{command}{\pgfsys@animation@rotate\marg{1}\marg{2}\marg{3}\marg{4}{}}
  To be written\dots
% % \marg{1} must be dimensionless, \marg{2},\marg{3} describe the origin of the rotation
% % and must be dimensions, \marg{4} is the key to which this is added
\end{command}

\begin{command}{\pgfsys@animation@viewbox\marg{1}\marg{2}\marg{3}\marg{4}\marg{5}{}}
  To be written\dots
% % \marg{1},\marg{2} describe the lower left, \marg{3},\marg{4} the upper right corner of the
% % view box. \marg{5} is the key to which this is added
\end{command}

\fi



\subsection{Object Identification System Commands}
\label{section-sys-id}

The system layer provides commands for adding identification labels
(ids) to different objects in a graphic. These can be used for
hyperlinking, which is needed for instance in conjunction with
animations.

The following ``objects'' can get an id assigned to them:
\begin{enumerate}
\item Graphic scopes (namely when |\pgfsys@begin@idscope| is called),
\item view boxes (namely when |\pgfsys@viewboxmeet| or |\pgfsys@viewboxslice| are called),
\item paths (namely when |\pgfsys@fill|, |\pgfsys@stroke|, and so on are called),
\item text boxes (namely when |\pgfsys@hbox| or |\pgfsys@hboxsynced| is called), and
\item animations (namely when |\pgfsys@animate...| is called).
\end{enumerate}


Creating and using ids is a two-step process. First, you create the
id using |\pgfsys@new@id|, which stores a fresh id in a macro. You can
now pass this id around and clone it. Then, at some point, you wish
one of the above objects to actually get this id. For this, you use
|\pgfsys@use@id| just \emph{before} the object since this command
always influences the \emph{next} object.

The basic id management gets more powerful when you use \emph{id
  types}. The idea is as follows: In reality, the objects from above
do not get assigned only an id, but rather a combination of an id and
a type -- and you can set the type independently of the id. This is
used, for instance, to allow easy access to the different parts of a
node in animations: Each node has a single id, but consists of several
graphic objects (normally, at least a background path and a
text). Each of these uses the same underlying id of the node, but the
path has the type |path| (actually |background.path|) while the text
has the type |text|. The advantage is that for each node only one id
must be stored instead of a great number of the many different
possible parts of a node.

\begin{command}{\pgfsys@new@id\marg{macro}}
  Creates a new id for later use and stores it in \meta{macro}. It is
  an internal text created by the driver and may not be changed or
  modified. 
\end{command}

\begin{command}{\pgfsys@use@id\marg{id}}
  ``Uses'' an id previously created using |\pgfsys@new@id|. This
  causes the \emph{next} graphic object to get the \meta{id} (not the
  current one). Once used, the id-type-pair becomes \emph{invalid} and
  will not be attached to any other graphics objects. It is, however,
  not an error to try this. If \meta{id} is empty, no id-type-pair is
  attached to the next object.
\end{command}

\begin{command}{\pgfsys@use@type\marg{type}}
  Changes the type used with the next graphic object.
  As mentioned earlier, the id assigned to the next object is actually
  a pair consisting of the currently used id and the currently used
  type. 
\end{command}

\begin{command}{\pgfsys@append@type\marg{text}}
  Appends the \meta{text} to the current type. 
\end{command}

\begin{command}{\pgfsys@push@type}
  Pushes the current type on a global ``stack of types'' without
  opening a \TeX\ scope. The is useful when you temporarily wish to
  change the type (for instance, by appending something to it), but
  you cannot create a new scope.
\end{command}

\begin{command}{\pgfsys@pop@type}
  Restores the most recently pushed type.
\end{command}

\begin{command}{\pgfsys@begin@idscope}
  Starts a (graphics) scope whose sole purpose is to assign it an
  id-type-pair so that it can be referenced later. Note that this
  command does not always produce a graphics scope: If not id is
  currently in use or if the id-type-pair has already been used,
  a graphic scope may or may not be created as defined by the driver
  (but always a \TeX\ scope). This allows drivers to minimize the
  number of graphic scopes created.

  When an id scope is created, any code that has been ``attached'' to
  it using |\pgfsys@attach@to@id| gets executed, see that command.

  Note that |\pgfsys@beginscope| does not use the current
  id-type-pair. You need to call this command to attach an id to a
  group. 
\end{command}

\begin{command}{\pgfsys@end@idscope}
  Ends the graphics id scope started by |\pgfsys@end@idscope|. It must
  nest correctly with other graphic scopes and \TeX\ scopes.
\end{command}


\begin{command}{\pgfsys@attach@to@id\marg{id}\marg{type}\marg{begin
      code}\marg{end code}}
  Attaches some code to the \meta{id}-\meta{type}-pair, where
  \meta{id} must have been created using |\pgfsys@new@id|. The effect
  is that when the id scope for this pair, the \meta{begin code} is
  executed at the beginning and \meta{end code} at the end. Multiple
  calls of this macro accumulated.
\end{command}


\subsection{Reusable Objects System Commands}

\begin{command}{\pgfsys@invoke\marg{literals}}
  This command gets protocolled literals and should insert them into
  the |.pdf| or |.dvi| file using an appropriate |\special|.
\end{command}

\begin{command}{\pgfsys@defobject\marg{name}\marg{lower
      left}\marg{upper right}\marg{code}}
  Declares an object for later use. The idea is that the object can be
  precached in some way and then be rendered more quickly when used
  several times. For example, an arrow head might be defined and
  prerendered in this way.

  The parameter \meta{name} is the name for later use. \meta{lower
  left} and \meta{upper right} are \pgfname\ points specifying a bounding
  box for the object. \meta{code} is the code for the object. The code
  should not be too fancy.

  This command has a default implementation and need not be
  implemented by a driver file.
\end{command}

\begin{command}{\pgfsys@useobject\marg{name}\marg{extra code}}
  Renders a previously declared object. The first parameter is the
  name of the object. The second parameter is extra code that
  should be executed right \emph{before} the object is
  rendered. Typically, this will be some transformation code.

  This command has a default implementation and need not be
  implemented by a driver file.
\end{command}


\subsection{Invisibility System Commands}

All drawing or stroking or text rendering between calls of the
following commands should be suppressed. A similar effect can be
achieved by clipping against an empty region, but the following
commands do not open a graphics scope and can be opened and closed
``orthogonally'' to other scopes.

\begin{command}{\pgfsys@begininvisible}
  Between this command and the closing |\pgfsys@endinvisible| all
  output should be suppressed. Nothing should be drawn at all, which
  includes all paths, images and shadings. However, no groups (neither
  \TeX\ groups nor graphic state groups) should be opened by this
  command.

  This command has a default implementation and need not be
  implemented by a driver file.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@endinvisible}
  Ends the invisibility section, unless invisibility blocks have been
  nested. In this case, only the ``last'' one restores visibility.

  This command has a default implementation and need not be
  implemented by a driver file.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}



\subsection{Page Size Commands}

The following commands can be used to set the page size of a document
in a ``portable'' way. Note, however, that many packages also (try to)
set the page size.

These commands are typically not given inside a |{pgfpicture}|, but on
the outer level of compilation.

\begin{command}{\pgfsys@papersize\marg{width}\marg{height}}
  Inserts the necessary |\special|s for the current driver into the
  output stream to ``locally'' change the page size. Whether such a
  ``local'' change is possible depends strongly on the driver. For
  instance, |dvips| will honor the first call to this command that is
  part of the shipped-out document and will ignore all other uses. In
  contrast, |pdftex| will use the current value of the paper size for
  each page and, additionally, setting the papersize is local to the
  current \TeX\ group.
\end{command}

\begin{command}{\pgfsys@global@papersize\marg{width}\marg{height}}
  Like the previous command, only for drivers where setting the paper
  size parameters is a \TeX-group-local operation, |\global| is
  prefixed to the setting of the page sizes. 
\end{command}

\begin{command}{\pgfsys@thepageheight}
  This macro expands to the current page's height, provided \LaTeX\ is
  used, otherwise a best guess is returned (currently just |\the\vsize|). 
\end{command}

\begin{command}{\pgfsys@thepagewidth}
  As above.
\end{command}

\subsection{Position Tracking Commands}

The following commands are used to determine the position of text on a
page. This is a rather complicated process in general since at the
moment when the text is read by \TeX, the final position cannot be
determined, yet. For example, the text might be put in a box which is
later put in the headline or perhaps in the footline or perhaps even
on a different page.

For these reasons, position tracking is typically a two-stage
process. In a first stage you indicate that a certain position is of
interest by \emph{marking} it. This will (depending on the details of
the backend driver) cause page coordinates or this position to be
written to an |.aux| file when the page is shipped. Possibly, the
position might also be determined at an even later stage. Then, on a
second run of \TeX, the position is read from the |.aux| file and can
be used.

\begin{command}{\pgfsys@markposition\marg{name}}
  Marks a position on the page. This command should be given while
  normal typesetting is done such as in
\begin{codeexample}[code only]
The value of $x$ is \pgfsys@markposition{here}important.
\end{codeexample}
  It causes the position |here| to be saved when the page is shipped
  out.
\end{command}

\begin{command}{\pgfsys@getposition\marg{name}\marg{macro}}
  This command retrieves a position that has been marked on an earlier
  run of \TeX\ on the current file. The \meta{macro} must be a macro
  name such as |\mymacro|. It will be redefined such that it is
  \begin{itemize}
  \item either just |\relax| or
  \item a |\pgfpoint...| command.
  \end{itemize}
  The first case will happen when the position has not been marked at
  all or when the file is typeset for the first time, when the
  coordinates are not yet available.

  In the second case, executing \meta{macro} yields the position on
  the page that is to be interpreted as follows: A coordinate like
  |\pgfpoint{2cm}{3cm}| means ``2cm to the right and 3cm up from the
  origin of the page.'' The position of the origin of the page is not
  guaranteed to be at the lower left corner, it is only guaranteed
  that all pictures on a page use the same origin.

  To determine the lower left corner of a page, you can call
  |\pgfsys@getposition| with \meta{name} set to the special name
  |pgfpageorigin|. By shifting all positions by the amount returned by
  this call you can position things absolutely on a page.

  \example Referencing a point of the page:
\begin{codeexample}[code only]
The value of $x$ is \pgfsys@markposition{here}important.

Lots of text.

\hbox{\pgfsys@markposition{myorigin}%
\begin{pgfpicture}
  % Switch of size protocol
  \pgfpathmoveto{\pgfpointorigin}
  \pgfusepath{use as bounding box}

  \pgfsys@getposition{here}{\hereposition}
  \pgfsys@getposition{myorigin}{\thispictureposition}

  \pgftransformshift{\pgfpointscale{-1}{\thispictureposition}}
  \pgftransformshift{\hereposition}

  \pgfpathcircle{\pgfpointorigin}{1cm}
  \pgfusepath{draw}
\end{pgfpicture}}
\end{codeexample}
\end{command}


\subsection{Internal Conversion Commands}

The system commands take \TeX\ dimensions as input, but the dimensions
that have to be inserted into \pdf\ and PostScript files need to be
dimensionless values that are interpreted as multiples of
$\frac{1}{72}\mathrm{in}$. For example, the \TeX\ dimension $2bp$
should be inserted as |2| into a \pdf\ file and the \TeX\ dimension
$10\mathrm{pt}$ as |9.9626401|. To make this conversion easier, the following
command may be useful:

\begin{command}{\pgf@sys@bp\marg{dimension}}
  Inserts how many multiples of $\frac{1}{72}\mathrm{in}$ the
  \meta{dimension} is into the current protocol stream (buffered).

  \example |\pgf@sys@bp{\pgf@x}| or |\pgf@sys@bp{1cm}|.
\end{command}

Note that this command is \emph{not} a system command that can/needs
to be overwritten by a driver.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "pgfmanual"
%%% End:
