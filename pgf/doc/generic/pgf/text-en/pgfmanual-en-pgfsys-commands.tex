% Copyright 2006 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.


\section{Commands of the System Layer}

\makeatletter

\subsection{Beginning and Ending a Stream of System Commands}

A ``user'' of the \pgfname\ system layer (like the basic layer or a
frontend) will interface with the system layer by calling a stream of
commands starting with |\pgfsys@|. From the system layer's point of
view, these commands form a long stream. Between calls to the system
layer, control goes back to the user.

The driver files implement system layer commands by inserting
|\special| commands that implement the desired operation. For example,
|\pgfsys@stroke| will be mapped to |\special{pdf: S}| by the driver
file for |pdftex|.

For many drivers, when such a stream of specials starts, it is
necessary to install an appropriate transformation and perhaps perform
some more bureaucratic tasks. For this reason, every stream will start
with a |\pgfsys@beginpicture| and will end with a corresponding ending
command.

\begin{command}{\pgfsys@beginpicture}
  Called at the beginning of a |{pgfpicture}|. This command should
  ``set up things.''

  Most drivers will need to implement this command.
\end{command}

\begin{command}{\pgfsys@endpicture}
  Called at the end of a |{pgfpicture}|.

  Most drivers will need to implement this command.
\end{command}

\begin{command}{\pgfsys@typesetpicturebox\marg{box}}
  Called \emph{after} a |{pgfpicture}| has been typeset. The picture
  will have been put in box \meta{box}. This command should insert the
  box into the normal text. The box \meta{box} will still be a ``raw''
  box that contains only the |\special|'s that make up the description
  of the picture. The  job of this command is to resize and shift
  \meta{box} according to the  baseline shift and the size of the
  box.

  This command has a default implementation and need not be
  implemented by a driver file.
\end{command}

\begin{command}{\pgfsys@beginpurepicture}
  This version of the |\pgfsys@beginpicture| picture command can be
  used for pictures that are guaranteed not to contain any escaped
  boxes (see below). In this case, a driver might provide a more
  compact version of the command.

  This command has a default implementation and need not be
  implemented by a driver file.
\end{command}

\begin{command}{\pgfsys@endpurepicture}
  Called at the end of a ``pure'' |{pgfpicture}|.

  This command has a default implementation and need not be
  implemented by a driver file.
\end{command}

Inside a stream it is sometimes necessary to ``escape'' back into
normal typesetting mode; for example to insert some normal text, but
with all of the current transformations and clippings being in
force. For this escaping, the following command is used:

\begin{command}{\pgfsys@hbox\marg{box number}}
  Called to insert a (horizontal) TeX box inside a
  |{pgfpicture}|.

  Most drivers will need to (re-)implement this command.
\end{command}

\begin{command}{\pgfsys@hboxsynced\marg{box number}}
  Called to insert a (horizontal) TeX box inside a
  |{pgfpicture}|, but with the current coordinate transformation
  matrix synced with the canvas transformation matrix.

  This command should do the same as if you used
  |\pgflowlevelsynccm| followed by |\pgfsys@hbox|. However, the default
  implementation of this command will use a ``TeX-translation'' for
  the translation part of the transformation matrix. This will ensure
  that hyperlinks ``survive'' at least translations. On the other
  hand, a driver may choose to revert to a simpler
  implementation. This is done, for example, for the \textsc{svg}
  implementation, where a \TeX-translation makes no sense.
\end{command}

\begin{command}{\pgfsys@pictureboxsynced\marg{box number}}
  Basically, this should do the same as doing a (scoped) low level sync
  followed by inserting the box \meta{box number} directly into the
  output stream. However, the default implementation uses
  |\pgfsys@hboxsynced| in conjunction with |\pgfsys@beginpicture| to
  ensure that, if possible, hyperlinks survive in
  \textsc{pdf}s. Drivers that are sensitive to picture-in-picture
  scopes should replace this implementation by
\begin{codeexample}[code only]
\pgfsys@beginscope\pgflowlevelsynccm\box#1\pgfsys@endscope
\end{codeexample}
\end{command}



\subsection{Scoping System Commands}

The scoping commands are used to keep changes of the graphics state
local.

\begin{command}{\pgfsys@beginscope}
  Saves the current graphic state on a graphic state stack. All
  changes to the graphic state parameters mentioned for |\pgfsys@stroke|
  and |\pgfsys@fill| will be local to the current graphic state and
  the old values will be restored after |\pgfsys@endscope| is used.

  \emph{Warning:} \pdf\ and PostScript differ with respect to the
  question of whether the current path is part of the graphic state or
  not. For this reason, you should never use this command unless the
  path is currently empty. For example, it might be a good idea to use
  |\pgfsys@discardpath| prior to calling this command.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@endscope}
  Restores the last saved graphic state.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}




\subsection{Path Construction System Commands}

\begin{command}{\pgfsys@moveto\marg{x}\marg{y}}
  This command is used to start a path at a specific point
  $(x,y)$ or to move the current point of the current path to  $(x,y)$
  without drawing anything upon stroking (the current path is
  ``interrupted'').

  Both \meta{x} and \meta{y} are given as \TeX\ dimensions. It is the
  driver's job to transform these to the coordinate system of the
  backend. Typically, this means converting the \TeX\ dimension into a
  dimensionless multiple of $\frac{1}{72}\mathrm{in}$. The function
  |\pgf@sys@bp| helps with this conversion.

  \example Draw a line from $(10\mathrm{pt},10\mathrm{pt})$ to the
  origin of the picture.
\begin{codeexample}[code only]
\pgfsys@moveto{10pt}{10pt}
\pgfsys@lineto{0pt}{0pt}
\pgfsys@stroke
\end{codeexample}

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@lineto\marg{x}\marg{y}}
  Continue the current path to $(x,y)$ with
  a straight line.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@curveto\marg{$x_1$}\marg{$y_1$}\marg{$x_2$}\marg{$y_2$}\marg{$x_3$}\marg{$y_3$}}
  Continue the current path to $(x_3,y_3)$
  with a B\'ezier curve that has the two control points  $(x_1,y_1)$ and  $(x_2,y_2)$.

  \example Draw a good approximation of a quarter circle:
\begin{codeexample}[code only]
\pgfsys@moveto{10pt}{0pt}
\pgfsys@curveto{10pt}{5.55pt}{5.55pt}{10pt}{0pt}{10pt}
\pgfsys@stroke
\end{codeexample}

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@rect\marg{x}\marg{y}\marg{width}\marg{height}}
  Append a rectangle to the current path whose lower left corner is
  at $(x,y)$ and whose width and height in
  big points are  given by \meta{width} and \meta{height}.

  This command can be ``mapped back'' to |\pgfsys@moveto| and
  |\pgfsys@lineto| commands, but it is included since \pdf\ has a
  special, quick version of this command.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@closepath}
  Close the current path. This results in joining the current point of
  the path with the point specified by the last |\pgfsys@moveto|
  operation. Typically, this is preferable over using |\pgfsys@lineto|
  to the last point specified by a |\pgfsys@moveto|, since the line
  starting at this point and the line ending at this point will be
  smoothly joined by |\pgfsys@closepath|.

  \example Consider
\begin{codeexample}[code only]
\pgfsys@moveto{0pt}{0pt}
\pgfsys@lineto{10bp}{10bp}
\pgfsys@lineto{0bp}{10bp}
\pgfsys@closepath
\pgfsys@stroke
\end{codeexample}
  and
\begin{codeexample}[code only]
\pgfsys@moveto{0bp}{0bp}
\pgfsys@lineto{10bp}{10bp}
\pgfsys@lineto{0bp}{10bp}
\pgfsys@lineto{0bp}{0bp}
\pgfsys@stroke
\end{codeexample}

  The difference between the above will be that in the second triangle
  the corner at the origin will be wrong; it will just be the overlay
  of two lines going in different directions, not a sharp pointed
  corner.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}




\subsection{Canvas Transformation System Commands}

\begin{command}{\pgfsys@transformcm\marg{a}\marg{b}\marg{c}\marg{d}\marg{e}\marg{f}}
  Perform a concatenation of the canvas transformation matrix with the
  matrix given by the values \meta{a} to \meta{f}, see the \pdf\ or
  PostScript manual for details. The values \meta{a} to \meta{d} are
  dimensionless factors, \meta{e} and \meta{f} are \TeX\ dimensions

  \example |\pgfsys@transformcm{1}{0}{0}{1}{1cm}{1cm}|.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@transformshift\marg{x displacement}\marg{y displacement}}
  This command will change the origin of the canvas to $(x,y)$.

  This command has a default implementation and need not be
  implemented by a driver file.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@transformxyscale\marg{x scale}\marg{y scale}}
  This command will scale the canvas (and  everything that is drawn)
  by a factor of \meta{x scale} in the $x$-direction and \meta{y
    scale} in the  $y$-direction. Note that this applies to
  everything, including  lines. So a scaled line will have a different
  width and may even have a different width when going along the
  $x$-axis and when going along the $y$-axis, if the scaling is
  different in these directions. Usually, you do not want this.

  This command has a default implementation and need not be
  implemented by a driver file.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@viewboxmeet\marg{$x_1$}\marg{$y_1$}\marg{$x_2$}\marg{$y_2$}%
    \marg{$x'_1$}\marg{$y'_1$}\marg{$x'_2$}\marg{$y'_2$}}
  Starts a ``view box'' scope, which must be ended using
  |\pgfsys@endviewbox| later on (with matching scopes).

  The effect of this command is as follows: Consider the rectangles $R$
  with lower left corner $(x_1,y_1)$ and upper right corner
  $(x_2,y_2)$ and $R'$ with corners $(x'_1,y'_1)$ and
  $(x'_2,y'_2)$. The command will install a canvas translation and
  uniform scaling such that $R'$ then has the same center as~$R$ and
  additionally, has maximum size such that it still fits
  inside~$R$. (Think of this as ``viewing'' $R'$ through $R$ such that
  the aspect ratio is kept.)
  
  This command has a default implementation. Its main purpose is to
  allow animations of the view box; for static drawings it is better
  to compute the necessary transformations directly.
\end{command}

\begin{command}{\pgfsys@viewboxslice\marg{$x_1$}\marg{$y_1$}\marg{$x_2$}\marg{$y_2$}%
    \marg{$x'_1$}\marg{$y'_1$}\marg{$x'_2$}\marg{$y'_2$}}
  Works like the previous command, but now $R'$ has minimal size such
  that it encompasses all of $R$.
\end{command}

\begin{command}{\pgfsys@endviewbox}
  Ends a viewbox previously started using |\pgfsys@viewboxmeet| or the
  |...slice| variant.
\end{command}


\subsection{Stroking, Filling, and Clipping System Commands}

\begin{command}{\pgfsys@stroke}
  Stroke the current path (as if it were drawn with a pen). A number
  of graphic state parameters influence this, which can be
  set using appropriate system commands described later.

  \begin{description}
  \item[Line width]
    The ``thickness'' of the line. A width of 0 is the thinnest width
    renderable on the device. On a high-resolution printer this may
    become invisible and should be avoided. A good choice is 0.4pt,
    which is the default.

  \item[Stroke color]
    This special color is used for stroking. If it is not set, the
    current color is used.

  \item[Cap]
    The cap describes how the endings of lines are drawn. A round cap
    adds a little half circle to these endings. A butt cap ends the
    lines exactly at the end (or start) point without anything
    added. A rectangular cap ends the lines like the butt cap, but the
    lines protrude over the endpoint by the line thickness. (See also
    the \pdf\ manual.) If the path has been closed, no cap
    is drawn.

  \item[Join]
    This describes how a bend (a join) in a path is rendered. A round
    join draws bends using small arcs. A bevel join just draws the two
    lines and then fills the join minimally so that it becomes
    convex. A miter join extends the lines so that they form a single
    sharp corner, but only up to a certain miter limit. (See the \pdf\
    manual once more.)

  \item[Dash]
    The line may be dashed according to a dashing pattern.

  \item[Clipping area]
    If a clipping area is established, only those parts of the path
    that are inside the clipping area will be drawn.
  \end{description}

  In addition to stroking a path, the path may also be used for
  clipping after it has been stroked. This will happen if the
  |\pgfsys@clipnext| is used prior to this command, see there for
  details.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@closestroke}
  This command should have the same effect as first closing the path
  and then stroking it.

  This command has a default implementation and need not be
  implemented by a driver file.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@fill}
  This command fills the area surrounded by the current path. If the
  path has not yet been closed, it is closed prior to filling. The
  path itself is not stroked. For self-intersecting paths or paths
  consisting of multiple parts, the nonzero winding number rule is
  used to determine whether a point is inside or outside the
  path, except if |\ifpgfsys@eorule| holds -- in which case the
  even-odd rule should be used. (See the \pdf\ or PostScript manual
  for details.)

  The following graphic state parameters influence the filling:

  \begin{description}
  \item[Interior rule]
    If |\ifpgfsys@eorule| is set, the even-odd rule is used, otherwise
    the non-zero winding number rule.

  \item[Fill color]
    If the fill color is not especially set, the current color is
    used.

  \item[Clipping area]
    If a clipping area is established, only those parts of the filling
    area that are inside the clipping area will be drawn.
  \end{description}

  In addition to filling the path, the path will also be used for
  clipping if |\pgfsys@clipnext| is used prior to this command.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@fillstroke}
  First, the path is filled, then the path is stroked. If the fill and
  stroke colors are the same (or if they are not specified and the
  current color is used), this yields almost the same as a
  |\pgfsys@fill|. However, due to the line thickness of the stroked
  path, the fill-stroked area will be slightly larger.

  In addition to stroking and filling the path, the path will also be
  used for clipping if |\pgfsys@clipnext| is used prior to this command.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@discardpath}
 Normally, this command should ``throw away'' the current path.
 However, after |\pgfsys@clipnext| has been called, the current path
 should subsequently be used for clipping. See |\pgfsys@clipnext| for
 details.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}


\begin{command}{\pgfsys@clipnext}
  This command should be issued after a path has been constructed, but
  before it has been stroked and/or filled or discarded. When the
  command is used, the next stroking/filling/discarding command will
  first be executed normally. Then, afterwards, the just-used path
  will be used for subsequent clipping. If there has already been a
  clipping region, this region is intersected with the new clipping
  path (the clipping cannot get bigger). The nonzero winding number
  rule is used to determine whether a point is inside or outside the
  clipping area or the even-odd rule, depending on whether
  |\ifpgfsys@eorule| holds.
\end{command}




\subsection{Graphic State Option System Commands}

\begin{command}{\pgfsys@setlinewidth\marg{width}}
  Sets the width of lines, when stroked, to \meta{width}, which must
  be a \TeX\ dimension.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@buttcap}
  Sets the cap to a butt cap. See |\pgfsys@stroke|.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@roundcap}
  Sets the cap to a round cap. See |\pgfsys@stroke|.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@rectcap}
  Sets the cap to a rectangular cap. See |\pgfsys@stroke|.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@miterjoin}
  Sets the join to a miter join. See |\pgfsys@stroke|.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@setmiterlimit\marg{factor}}
  Sets the miter limit of lines to \meta{factor}. See
  the \pdf\ or PostScript for details on what the miter limit is.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@roundjoin}
  Sets the join to a round join. See |\pgfsys@stroke|.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@beveljoin}
  Sets the join to a bevel join. See |\pgfsys@stroke|.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@setdash\marg{pattern}\marg{phase}}
  Sets the dashing patter. \meta{pattern} should be a list of \TeX\
  dimensions separated by commas. \meta{phase} should be a
  single dimension.

  \example |\pgfsys@setdash{3pt,3pt}{0pt}|

  The list of values in \meta{pattern} is used to determine the
  lengths of the ``on'' and ``off'' phases of the dashing. For example, if \meta{pattern} is |3bp,4bp|, then the dashing
  pattern is ``3bp on followed by 4bp off, followed by 3bp on,
  followed by 4bp off, and so on.'' A pattern of |.5pt,4pt,3pt,1.5pt| means
  ``.5pt on, 4pt off, 3pt on, 1.5pt off, .5pt on, \dots'' If the
  number of entries is odd, the last one is used twice, so |3pt| means
  ``3pt on, 3pt off, 3pt on, 3pt off, \dots'' An empty list
  means  ``always on.''

  The second argument determines the ``phase'' of the pattern. For
  example, for a pattern of |3bp,4bp| and a phase of |1bp|, the pattern
  would start: ``2bp on, 4bp off, 3bp on, 4bp off, 3bp on, 4bp off,
  \dots''

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

{\let\ifpgfsys@eorule=\relax
\begin{command}{\ifpgfsys@eorule}
  Determines whether the even odd rule is used for filling and
  clipping or not.
\end{command}
}


\subsection{Color System Commands}

The \pgfname\ system layer provides a number of system commands for
setting colors. These command coexist with commands from the |color|
and |xcolor| package, which perform similar functions. However, the
|color| package does not support having two different colors for
stroking and filling, which is a useful feature that is supported by
\pgfname. For this reason, the \pgfname\ system layer offers commands for
setting these colors separately. Also, plain \TeX\ profits from the
fact that \pgfname\ can set colors.

For \pdf, implementing these color commands is easy since \pdf\
supports different stroking and filling colors directly. For
PostScript, a more complicated approach is needed in which the colors
need to be stored in special PostScript variables that are set
whenever a stroking or a filling operation is done.

\begin{command}{\pgfsys@color@rgb\marg{red}\marg{green}\marg{blue}}
  Sets the color used for stroking and filling operations to the given
  red/green/blue tuple (numbers between 0 and 1).

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@rgb@stroke\marg{red}\marg{green}\marg{blue}}
  Sets the color used for stroking operations to the given
  red/green/blue tuple (numbers between 0 and 1).

  \example Make stroked text dark red: |\pgfsys@color@rgb@stroke{0.5}{0}{0}|

  The special stroking color is only used if the stroking color has
  been set since the last |\color| or |\pgfsys@color@...|
  command. Thus, each |\color| command will reset both the stroking
  and filling colors by calling |\pgfsys@color@reset|.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@rgb@fill\marg{red}\marg{green}\marg{blue}}
  Sets the color used for filling operations to the given
  red/green/blue tuple (numbers between 0 and 1). This color may be
  different from the stroking color.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@cmyk\marg{cyan}\marg{magenta}\marg{yellow}\marg{black}}
  Sets the color used for stroking and filling operations to the given
  cmyk tuple (numbers between 0 and 1).

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@cmyk@stroke\marg{cyan}\marg{magenta}\marg{yellow}\marg{black}}
  Sets the color used for stroking operations to the given cmyk tuple
  (numbers between 0 and 1).

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@cmyk@fill\marg{cyan}\marg{magenta}\marg{yellow}\marg{black}}
  Sets the color used for filling operations to the given cmyk tuple
  (numbers between 0 and 1).

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@cmy\marg{cyan}\marg{magenta}\marg{yellow}}
  Sets the color used for stroking and filling operations to the given
  cmy tuple (numbers between 0 and 1).

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@cmy@stroke\marg{cyan}\marg{magenta}\marg{yellow}}
  Sets the color used for stroking operations to the given cmy tuple
  (numbers between 0 and 1).

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@cmy@fill\marg{cyan}\marg{magenta}\marg{yellow}}
  Sets the color used for filling operations to the given cmy tuple
  (numbers between 0 and 1).

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@gray\marg{black}}
  Sets the color used for stroking and filling operations to the given
  black value, where 0 means black and 1 means white.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@gray@stroke\marg{black}}
  Sets the color used for stroking operations to the given black value,
  where 0 means black and 1 means white.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@gray@fill\marg{black}}
  Sets the color used for filling operations to the given black value,
  where 0 means black and 1 means white.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@color@reset}
  This command will be called when the |\color| command is used. It
  should purge any internal settings of stroking and filling
  color. After this call, till the next use of a command like
  |\pgfsys@color@rgb@fill|, the current color installed by the
  |\color| command should be used.

  If the \TeX-if |\pgfsys@color@reset@inorder| is set to true, this
  command may ``assume'' that any call to a color command that sets
  the fill or stroke color came ``before'' the call to this command
  and may try to optimize the output accordingly.

  An example of an incorrect ``out of order'' call would be using
  |\pgfsys@color@reset| at the beginning of a box that is constructed
  using |\setbox|. Then, when the box is constructed, no special fill
  or stroke color might be in force. However, when the box is later on
  inserted at some point, a special fill color might already have been
  set. In this case, this command is not guaranteed to reset the color
  correctly.
\end{command}

\begin{command}{\pgfsys@color@reset@inordertrue}
  Sets the optimized ``in order'' version of the color resetting. This
  is the default.
\end{command}

\begin{command}{\pgfsys@color@reset@inorderfalse}
  Switches off the optimized color resetting.
\end{command}

\begin{command}{\pgfsys@color@unstacked\marg{\LaTeX\ color}}
  This slightly obscure command causes the color stack to be
  tricked. When called, this command should set the current color to
  \meta{\LaTeX\ color} without causing any change in the color stack.

  \example |\pgfsys@color@unstacked{red}|
\end{command}




\subsection{Pattern System Commands}


\begin{command}{\pgfsys@declarepattern
    \marg{name}\marg{$x_1$}\marg{$y_1$}\marg{$x_2$}\marg{$y_2$}
    \marg{$x$ step}\marg{$y$ step}\marg{code}\marg{flag}}
  This command declares a new colored or uncolored pattern, depending
  on whether \meta{flag} is |0|, which means uncolored, or |1|, which
  means colored. Uncolored patterns have no inherent color, the color
  is provided when they are set. Colored patters have an inherent
  color.

  The \meta{name} is a name for later use when the pattern is to be
  shown. The pairs $(x_1,y_1)$ and $(x_2,y_2)$ must describe a
  bounding box of the pattern \meta{code}.

  The tiling step of the pattern is given by \meta{$x$ step} and
  \meta{$y$ step}.

  \example
\begin{codeexample}[code only]
\pgfsys@declarepattern{hori}{-.5pt}{0pt}{.5pt}{3pt}{3pt}{3pt}
{\pgfsys@moveto{0pt}{0pt}\pgfsys@lineto{0pt}{3pt}\pgfsys@stroke}
{0}
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@setpatternuncolored\marg{name}\marg{red}\marg{green}\marg{blue}}
  Sets the fill color to the pattern named \meta{name}. This pattern
  must previously have been declared with \meta{flag} set to |0|. The
  color of the pattern is given in the parameters \meta{red},
  \meta{green}, and \meta{blue} in the usual way.

  The fill color ``pattern''  will persist till the next color command
  that modifies the fill color.
\end{command}

\begin{command}{\pgfsys@setpatterncolored\marg{name}}
  Sets the fill color to the pattern named \meta{name}. This pattern
  must have been declared with the |1| flag.
\end{command}




\subsection{Image System Commands}

The system layer provides some commands for image inclusion.

\begin{command}{\pgfsys@imagesuffixlist}
  This macro should expand to a list of suffixes, separated by `:',
  that will be tried when searching for an image.

  \example |\def\pgfsys@imagesuffixlist{eps:epsi:ps}|
\end{command}


\begin{command}{\pgfsys@defineimage}
  Called, when an image should be defined.

  This command does not take any parameters. Instead, certain macros
  will be preinstalled with appropriate values when this command is
  invoked. These are:

  \begin{itemize}
  \item\declare{|\pgf@filename|}
    File name of the image to be defined.

  \item\declare{|\pgf@imagewidth|}
    Will be set to the desired (scaled) width of the image.

  \item\declare{|\pgf@imageheight|}
    Will be set to the desired (scaled) height of the image.

    If this macro and also the height macro are empty, the image
    should have its ``natural'' size.

    If only one of them is specified, the undefined value the
    image is scaled so that the aspect ratio is kept.

    If both are set, the image is scaled in both directions
    independently, possibly changing the aspect ratio.
  \end{itemize}

  The following macros presumable mostly make sense for drivers that
  can handle \pdf:

  \begin{itemize}
  \item \declare{|\pgf@imagepage|}
    The desired page number to be extracted from a multi-page
    ``image.''

  \item\declare{|\pgf@imagemask|}
    If set, it will be set to |/SMask x 0 R| where |x| is the \pdf\
    object number of a soft mask to be applied to the image.

  \item\declare{|\pgf@imageinterpolate|}
    If set, it will be set to |/Interpolate true| or
    |/Interpolate false|, indicating whether the image should be
    interpolated in \pdf.
  \end{itemize}

  The command should now set up the macro |\pgf@image| such that calling
  this macro will result in typesetting the image. Thus, |\pgf@image| is
  the ``return value'' of the command.

  This command has a default implementation and need not be
  implemented by a driver file.
\end{command}



\subsection{Shading System Commands}


\begin{command}{\pgfsys@horishading\marg{name}\marg{height}\marg{specification}}
  Declares a horizontal shading for later use. The effect of this
  command should be the definition of a macro called |\@pgfshading|\meta{name}|!|
  (or |\csname @pdfshading|\meta{name}|!\endcsname|, to be
  precise). When invoked, this new macro should insert a shading at
  the current position.

  \meta{name} is the name of the shading, which is also used in the
  output macro name. \meta{height} is the height of the shading and
  must be given as a TeX dimension like |2cm| or
  |10pt|. \meta{specification} is a shading color
  specification as specified in Section~\ref{section-shadings}. The
  shading specification implicitly fixes the width of the shading.

  When |\@pgfshading|\meta{name}|!| is invoked, it should insert a box
  of height \meta{height} and the width implicit in the shading
  declaration.
\end{command}


\begin{command}{\pgfsys@vertshading\marg{name}\marg{width}\marg{specification}}
  Like the horizontal version, only for vertical shadings. This time,
  the height of the shading is implicit in \meta{specification} and
  the width is given as \meta{width}.
\end{command}

\begin{command}{\pgfsys@radialshading\marg{name}\marg{starting point}\marg{specification}}
  Declares a radial shading. Like the previous macros, this command
  should set up the macro |\@pgfshading|\meta{name}|!|, which upon
  invocation should insert a radial shading whose size is implicit in
  \meta{specification}.

  The parameter \meta{starting point} is a \pgfname\ point
  specifying the inner starting point of the shading.
\end{command}


\begin{command}{\pgfsys@functionalshading\marg{name}\marg{lower left
      corner}\meta{upper right corner}\marg{type 4 function}}
 Declares a shading using a PostScript-like function that provides a
 color for each point. Like the previous macros, this command
 should set up the macro |\@pgfshading|\meta{name}|!| so that it will
 produce a box containing the desired shading.

 Parameter \meta{name} is the name of the shading. Parameter
 \meta{type 4 function} is a
 Postscript-like function (type 4 function of the PDF specification)
 as described in Section 3.9.4 of the PDF specification version 1.7.
 Parameters \meta{lower left corner} and \meta{upper right corner} are
 \pgfname\ points that specifies the lower left and upper right
 corners of the shading, respectively.

 When \meta{type 4 function} is evaluated, the coordinate of the current
 point will be on the (virtual) PostScript stack in bp units. After
 the function has been evaluated, the stack should consist of three
 numbers (not integers! -- the Apple PDF renderer is broken in this
 regard, so add cvrs at the end if needed) that represent the red,
 green, and blue components of the color.

 A buggy function will result is \emph{totally unpredictable chaos} during
 rendering.
\end{command}



\subsection{Transparency System Commands}

\begin{command}{\pgfsys@opacity\marg{value}}
  Sets the opacity of all operations, treating stroking and filling as
  a transparency group. Some drivers support this operations, others
  do not and set the fill and stroke individually. This difference can
  only be seen when a path is stroked and filled at the same time:
  When the drawing and fill opacities are set individually, the effect
  of filling and drawing a path at the same time is the same as first
  filling the path and then drawing it. On the other, if the opacity
  is set using this command, the effect should rather be that same as
  first filling and then drawing the path without any opacity in an
  off-screen area and then copying the result to the target area with
  a homogeneous opacity of \meta{value}.

  Since \textsc{pdf} does not support this form of opacity, this
  command is only present on the system layer and not supported in the
  basic layer.
\end{command}

\begin{command}{\pgfsys@stroke@opacity\marg{value}}
  Sets the opacity of stroking operations.
\end{command}

\begin{command}{\pgfsys@fill@opacity\marg{value}}
  Sets the opacity of filling operations.
\end{command}

\begin{command}{\pgfsys@blend@mode\marg{value}}
  Sets the blend mode, see Section 7.2.4 of the \textsc{pdf}
  Specification, Version 1.7.
\end{command}

\begin{command}{\pgfsys@transparencygroupfrombox\marg{box}}
  This takes a \TeX\ box and converts it into a transparency
  group. This means that any transparency settings apply to the box as
  a whole. For instance, if a box contains two overlapping black
  circles and you draw the box and, thus, the two circles normally
  with 50\% transparency, then the overlap will be darker than the
  rest. By comparison, if the circles are part of a transparency
  group, the overlap will get the same color as the rest.
\end{command}

A transparency group can be \emph{isolated} and/or a \emph{knockout}
group (see Sections 7.3.4 and 7.3.5 of the \textsc{pdf}
Specification Version 1.7). Which of these is the case is dictated
by the current settings of the following two ifs, which must be set
before the above command is called:
  
{\let\ifpgfsys@transparency@group@isolated=\relax
\begin{command}{\ifpgfsys@transparency@group@isolated}
  Determines whether a transparency group should be isolated. 
\end{command}
}

{\let\ifpgfsys@transparency@group@knockout=\relax
\begin{command}{\ifpgfsys@transparency@group@knockout}
  Determines whether a transparency group is a knockout group or not. 
\end{command}
}


  
\begin{command}{\pgfsys@fadingfrombox\marg{name}\marg{box}}
  Declares the fading \meta{name}. The \meta{box} is a \TeX-box. Its
  content's luminosity determines the opacity of the resulting
  fading. This means that the lighter a pixel inside the box, the more
  opaque the fading will be at this position.
\end{command}

\begin{command}{\pgfsys@usefading\meta{name}\marg{a}\marg{b}\marg{c}\marg{d}\marg{e}\marg{f}}
  Installs a previously declared fading \meta{name} in the current
  graphics state. Afterwards, all drawings will be masked by the
  fading. The fading should be centered on the origin and have its
  original size, except that the parameters \meta{a} to \meta{f}
  specify a transformation matrix that should be applied additionally
  to the fading before it is installed. The transformation should not
  apply to the following graphics, however.
\end{command}


\begin{command}{\pgfsys@definemask}
  This command declares a fading (known as a soft mask in this
  context) based on an image and for usage with images. It
  works similar to |\pgfsys@defineimage|: Certain macros are set when
  the command is called. The result should be to set the macro
  |\pgf@mask| to a pdf object count that can subsequently be used as a
  transparency mask. The following macros will be set when this command is
  invoked:

  \begin{itemize}
  \item \declare{|\pgf@filename|}
    File name of the mask to be defined.

  \item \declare{|\pgf@maskmatte|}
    The so-called matte of the mask (see the \pdf\ documentation for
    details). The matte is a color specification consisting of 1, 3 or
    4 numbers between 0 and 1. The number of numbers depends on the
    number of color channels in the image (not in the mask!). It will
    be assumed that the image has been preblended with this color.
  \end{itemize}
\end{command}


\subsection{Animation Commands}

\def\animationtimingexample#1#2#3{ 
  \tikz[fill=blue!25, draw=blue, ultra thick] {
    \pgfidrefnextuse{\objid}{#1}
    \pgfsys@animation@whom{\objid}{#2}
    \pgfidrefnextuse{\nodeid}{node}
    \pgfsys@animation@event{\nodeid}{}{click}{}{begin}
    #3
    \node [font=\scriptsize, circle, fill, draw, align=center]
      (node) {Click \\ here};
  }
}
\def\animationexample#1#2#3{
  \animationtimingexample{#1}{#2}{
    \pgfsys@animation@time{0}{1}{1}{0}{0}
    \pgfsys@animation@val@current
    \pgfsys@animation@time{2}{1}{1}{0}{0}
    #3
  }
}


\subsubsection{The Animate Command}

In conjunction with the right output format (namely
\textsc{svg}), you can specify that certain parts of you graphics can
be animated. For this, there are a number of commands that
cover, currently, what \textsc{svg 1.1} can do regarding animations.
For a detailed introduction to animations, please see
Section~\ref{section-base-animations}; the current section assumes that you
are familiar with the concepts explained there.

To add an animation to a graphic, use the following command:

\begin{command}{\pgfsys@animate\marg{attribute}}
  The system layer animation subsystem follows the following
  philosophy: An animation always concerns an \emph{attribute} of a
  \emph{graphic object.} A \emph{timeline} specifies how the attribute
  changes its value over 
  time. Finally, a set of \emph{keys} configures the animation as a
  whole like whether the timeline repeats or a event that triggers the
  start of the animation. The four parts of an animation, namely the
  \emph{attribute}, the \emph{graphic object}, the \emph{timeline}, and
  the \emph{keys}, are specified in different ways: 

  \begin{enumerate}
  \item You choose the \emph{attribute} using the system layer command
    |\pgfsys@animate|.
  \item The \emph{graphic object} whose attribute is to be animated is
    \emph{always} specified by naming the ID of the graphic object
    \emph{before} this object is created, see
    Section~\ref{section-sys-id}. (However, in the context of
    \tikzname, it suffices that the animation is given in the object's
    options since these are executed before the actual object is
    created).
  \item The \emph{timeline} is specified using the commands
    |\pgfsys@animation@time|, which specifes a time in seconds, and
    |\pgfsys@animation@val...|, which specify a value at this particular
    time. The timeline specifies for a sequence of times the values the
    attribute will have at these times. In between these \emph{key
      times,} the value is interpolated.
  \item The \emph{animation keys} are specified by commands starting
    |\pgfsys@animation@...| and have the following effect: They set some
    property (like, say, whether the animation repeats or whether its
    effect is additive) to a given value \emph{for the current \TeX\
      scope,} but do not create any animations. Rather, when
    |\pgfsys@animate| is called, a snapshot of the current 
    values of all animation keys is taken and added to this animation of
    the attribute.
    
    When you set an animation key to a value, this will replace
    the value previously stored for the key (all keys are empty by
    default at the beginning).
    
    Note that animation keys are local to \TeX\ scopes, not graphics
    scopes; indeed, they have little to do with the settings of the
    graphics scope other than the fact that a graphic scope is also a
    \TeX\ scope and thereby influence the values of these keys.
  \end{enumerate}

  A typical example of how all of this works is the following:
\begin{codeexample}[code only]
\pgfsys@animation@repeat@indefinite % Both of the following animations
                                    % repeat indefinitely
{
  \pgfsys@animation@whom{\someid}{}% The id of a later object
  \pgfsys@animation@event{}{}{click}{0}{begin}% Begin on a click ...
  \pgfsys@animation@time{5}{1}{1}{0}{0} % Timeline starts after 5s
  \pgfsys@animation@val@scalar{0} % With a value of 0
  \pgfsys@animation@time{8}{1}{1}{0}{0} % Timeline ends after 8s
  \pgfsys@animation@val@scalar{0.9} % With a value of 0.9
  \pgfsys@animate{fillopacity}% ... and the attribute is the fill opacity
}
{
  \pgfsys@animation@whom{\someid}{}% The id of a later object
  \pgfsys@animation@offset{0}{begin}% Begin right away ...
  \pgfsys@animation@time{1}{1}{1}{0}{0} % Timeline starts after 1s
  \pgfsys@animation@val@current % With the current value
  \pgfsys@animation@time{5}{1}{1}{0}{0} % Timeline ends after 5s
  \pgfsys@animation@val@dimension{5pt} % With a value of 5pt
  \pgfsys@animate{linewidth}% ... and the attribute is the line width
}
\end{codeexample}
  As a real-life example, consider the following definitions, which
  will be used in many examples in the rest of this section:
  Both take take three parameters: The \pgfname/\tikzname\ name of a
  to-be animated object, a type (relevant for objects that have
  subtypes or parts), and some code 
  for triggering the actual animation. The animation will always start
  when the button is clicked. The second macro sets up things in such a
  way that the animation will last two seconds, while the first leaves
  the timing open.
\begin{codeexample}[code only]
\def\animationtimingexample#1#2#3{ 
  \tikz[fill=blue!25, draw=blue, ultra thick] {
    \pgfidrefnextuse{\objid}{#1}
    \pgfsys@animation@whom{\objid}{#2}
    \pgfidrefnextuse{\nodeid}{node}
    \pgfsys@animation@event{\nodeid}{}{click}{}{begin}
    #3
    \node [font=\scriptsize, circle, fill, draw, align=center]
      (node) {Click \\ here};
  }
}
\def\animationexample#1#2#3{
  \animationtimingexample{#1}{#2}{
    \pgfsys@animation@time{0}{1}{1}{0}{0}
    \pgfsys@animation@val@current
    \pgfsys@animation@time{2}{1}{1}{0}{0}
    #3
  }
}
\end{codeexample}
  Now the example, where the circle will disappear, when clicked:
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@scalar{0}
  \pgfsys@animate{opacity}
}
\end{codeexample}
\end{command}



\subsubsection{Commands for Animating an Attribute: Color, Opacity,
  Visibility, Staging}

The commands from this and the next sections specify that some
attribute should be animated. We start with rather basic animation
attributes for color, visibility, and opacity.



\begin{sysanimateattribute}{opacity}
  Adds an animation of the opacity to the graphic object specified
  using |\pgfsys@animation@whom|. If the driver supports this, this is
  a bit different from animating the fill and stroke opacities
  individually: Paths are treated as transparency groups for this
  key. Typically, ``this is what you want.''
  
  Specify values with |\pgfsys@animation@val@scalar|.

\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@scalar{0}
  \pgfsys@animate{opacity}
}
\end{codeexample}
\end{sysanimateattribute}

\begin{sysanimateattribute}{fillopacity}
  Adds an animation of only the opacity of fill operations.
  
  Specify values with |\pgfsys@animation@val@scalar|.

\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@scalar{0}
  \pgfsys@animate{fillopacity}
}
\end{codeexample}
\end{sysanimateattribute}

\begin{sysanimateattribute}{strokeopacity}
  Adds an animation of only the opacity of draw (stroke) operations.
  
  Specify values with |\pgfsys@animation@val@scalar|.
  
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@scalar{0}
  \pgfsys@animate{strokeopacity}
}
\end{codeexample}
\end{sysanimateattribute}

\begin{sysanimateattribute}{visibility}
  Adds an animation of the ``visiblity''.
  
  Specify values with |\pgfsys@animation@val@text|. However, only two values are allowed:
  |visible| and |hidden|.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@text{hidden}
  \pgfsys@animate{visibility}
}
\end{codeexample}
\end{sysanimateattribute}

\begin{sysanimateattribute}{stage}
  Adds an animation of the ``staging''. This is exactly the same as
  the |visibility| attribute, only the to-be-animated object is
  invisible by default. 
  
  Specify values with |\pgfsys@animation@val@text|. As for
  |visibility|, only two values are allowed: 
  |visible| and |hidden|.
\begin{codeexample}[width=4cm]
\animationexample{my node}{}{
  \pgfsys@animation@val@text{visible}
  \pgfsys@animate{stage}
  \node (my node) at (2,0) [fill=red, text=white] { Visible }; }
\end{codeexample}
\end{sysanimateattribute}

\begin{sysanimateattribute}{strokecolor}
  Adds an animation of the stroke color.

  Specify values with |\pgfsys@animation@val@color@rgb| and friends.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@color@rgb{1}{0}{0}
  \pgfsys@animate{strokecolor}
}
\end{codeexample}
\end{sysanimateattribute}

\begin{sysanimateattribute}{fillcolor}
  Adds an animation of the fill color.
  
  Specify values with |\pgfsys@animation@val@color@rgb| and friends.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@color@rgb{1}{0}{0}
  \pgfsys@animate{fillcolor}
}
\end{codeexample}
\end{sysanimateattribute}


\subsubsection{Commands for Animating an Attribute: Paths and Their Rendering}

The following attributes influence paths and how they are rendered.

\begin{sysanimateattribute}{path}
  Adds an animation of the path itself. That means that the path will
  morph its form from one path to another. When morphing a path, all
  ``values,'' which are the paths, must consist of the  \emph{exact
    same} path construction commands; they may only differ with
  respect to the numbers used in these descriptions.
  
  Specify values with |\pgfsys@animation@val@path|.
\begin{codeexample}[width=3.3cm]
\animationexample{my path}{path}{
  \pgfsys@animation@val@path{ \pgfpathmoveto{\pgfpointxy{0}{1}}
                              \pgfpathlineto{\pgfpointxy{2}{1}}
                              \pgfpathlineto{\pgfpointxy{0}{0}} }
  \pgfsys@animate{path}
  \filldraw [ultra thick,draw=blue,fill=blue!20, name=my path]
    (0,0) -- (1,1) -- (2,0); }
\end{codeexample}
\end{sysanimateattribute}

\begin{sysanimateattribute}{linewidth}
  Adds an animation of the line width.
  
  Specify values with |\pgfsys@animation@val@dimension|.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@dimension{10pt}
  \pgfsys@animate{linewidth}
}
\end{codeexample}
\end{sysanimateattribute}

\begin{sysanimateattribute}{dash}
  Adds an animation of the dash phase and pattern (like |\pgfsys@setdash|).
  
  Specify values with |\pgfsys@animation@val@dash|.
\begin{codeexample}[width=2cm]
\animationtimingexample{node}{}{
  \pgfsys@animation@time{0}{1}{1}{0}{0}
  \pgfsys@animation@val@dash{1pt,10pt}{0pt}
  \pgfsys@animation@time{2}{1}{1}{0}{0}
  \pgfsys@animation@val@dash{10pt,3pt}{0pt}
  \pgfsys@animate{dash}
}
\end{codeexample}
\begin{codeexample}[width=2cm]
\animationtimingexample{node}{}{
  \pgfsys@animation@time{0}{1}{1}{0}{0}
  \pgfsys@animation@val@dash{3pt,1pt}{0pt}
  \pgfsys@animation@time{2}{1}{1}{0}{0}
  \pgfsys@animation@val@dash{3pt,1pt}{10pt}
  \pgfsys@animate{dash}
}
\end{codeexample}
\begin{codeexample}[width=2cm]
\animationtimingexample{node}{}{
  \pgfsys@animation@time{0}{1}{1}{0}{0}
  \pgfsys@animation@val@dash{3pt,1pt}{0pt}
  \pgfsys@animation@time{2}{1}{1}{0}{0}
  \pgfsys@animation@val@dash{1pt,3pt}{10pt}
  \pgfsys@animate{dash}
}
\end{codeexample}
\end{sysanimateattribute}



\subsubsection{Commands for Animating an Attribute: Transformations  and Views}

The commands in this section allow you to animate the canvas
transformation matrix of a scope. However, there is one command that
needs to be explained first.

\begin{command}{\pgfsys@animation@canvas@transform\marg{pre}\marg{post}}
  In order to animate the canvas, you specify that, for instance, the
  canvas should be shifted over, say, one second by 2cm from left to
  right. In order to specify this, you specify that an additional
  shift should be added to the canvas transformation matrix that
  starts out as $(0,0)$ and ends at $(2\,\mathrm{cm},0)$. However, it
  is not immediately clear what ``to the right'' or
  $(2\,\mathrm{cm},0)$ actually means: ``Right'' relative to the
  paper? ``Right'' relative to the coordinate system at the point when the
  animation is created? ``Right'' relative to the object's local
  coordinate system?

  Using this command you can specify the coordinate system relative to
  which all canvas animations are specified. In detail, when you
  add an animation $a$ of the canvas of an object foo, the following
  happens: 

  \begin{enumerate}
  \item We start with the canvas transformation matrix that is
    installed when the object starts. More precisely, this is the
    canvas transformation matrix that is in force when the command
    |\pgfsys@begin@idscope| is called for the obejct. The canvas
    transformation matrix that is in force when the animation is
    created (which is typically ``way before'' the object is created
    and may even be in a totally different graphics scope) is
    irrelevant for the animation.
  \item Now, when the object is created, the code \meta{pre} is
    executed. It should call |\pgfsys@transformcm| at most once. This
    canvas transformation is added to the object's canvas
    transformation.
  \item Now, the animation $a$ of the canvas is relative to the
    resulting canvas transformation. That means, when the animation
    shifts the object ``to the right'' the animation will actually be
    along the current direction of ``right'' in the canvas
    transformation resulting from the two transformations above.
  \item Finally, at the point of creation of the to-be-animation
    object the code \meta{post} is executed. Again, the code
    should call |\pgfsys@transformcm| at most once. The resulting
    transformation is also added to the object's canvas
    transformation, but does \emph{not} influence the animation.
  \end{enumerate}

  The net effect of the above is that, normally, you use the
  \meta{pre} code to setup a transformation matrix relative to which
  you wish to perform your animation and, normally, you use
  \meta{post} to undo this transformation (using the inverted
  matrix) to ensure that when no animation is in force, the object is
  placed at the same position as if no animation were used. 

  Let us now have a look at some examples. We use the following macro,
  which takes a pre and a post code and animates a red ball over 1cm
  to the right in two seconds and rotates the blue ball over
  90$^\circ$ around the origin. The ball is placed at $(1,0)$.
  
\begin{codeexample}[code only]
\def\animationcanvasexample#1#2{%
  \animationexample{ball}{}{%
    \pgfsys@animation@canvas@transform{#1}{#2}%
    \pgfsys@animation@val@translate{1cm}{0cm}%
    \pgfsys@animate{translate}
    \fill [ball=red,name=ball] (1,0) circle [radius=3mm]; }
  \animationexample{ball}{}{%
    \pgfsys@animation@canvas@transform{#1}{#2}%
    \pgfsys@animation@val@scalar{90}%
    \pgfsys@animate{rotate}
    \fill [ball=blue,name=ball] (1,0) circle [radius=3mm]; } }
\end{codeexample}
\def\animationcanvasexample#1#2{%
  \animationexample{ball}{}{%
    \pgfsys@animation@canvas@transform{#1}{#2}%
    \pgfsys@animation@val@translate{1cm}{0cm}%
    \pgfsys@animate{translate}
    \fill [ball color=red,name=ball] (1,0) circle [radius=3mm]; }
  \animationexample{ball}{}{%
    \pgfsys@animation@canvas@transform{#1}{#2}%
    \pgfsys@animation@val@scalar{90}%
    \pgfsys@animate{rotate}
    \fill [ball color=blue,name=ball] (1,0) circle [radius=3mm]; }
}

\begin{codeexample}[width=5cm]
\animationcanvasexample
{}
{}
\end{codeexample}
\begin{codeexample}[width=5cm]
\animationcanvasexample
{\pgfsys@transformshift{10mm}{0mm}}
{\pgfsys@transformshift{-10mm}{0mm}}
\end{codeexample}
\begin{codeexample}[width=5cm]
\animationcanvasexample
{\pgfsys@transformcm{0.5}{0.5}{-0.5}{0.5}{0pt}{0pt}}
{}
\end{codeexample}
\begin{codeexample}[width=5cm]
\animationcanvasexample
{\pgfsys@transformcm{0.5}{0.5}{-0.5}{0.5}{0pt}{0pt}}
{\pgfsys@transformcm{1}{-1}{1}{1}{0pt}{0pt}}
\end{codeexample}

  \emph{Note:} Only one canvas transformation can be in force for each
  to-be-animated object. This means that if you add more than one
  animation to an object, the last one ``wins'' and applies to all of
  them. To apply more than one animation to an object with different
  canvas operations, you need to surround the object by several
  scopes, and apply the animations to the different scopes.
\end{command}


\begin{sysanimateattribute}{translate}
  Adds an (additional) translate animation. Effectively, this causes
  the group to be shifted to different positions.
  
  Specify values with |\pgfsys@animation@val@translate|. 
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{1cm}{1cm}
  \pgfsys@animate{translate}
}
\end{codeexample}
\end{sysanimateattribute}

\begin{sysanimateattribute}{scale}
  Adds an animation of the scaling relative to the origin. This causes
  a scaling of the canvas, including fonts and line widths.
  
  Specify values with |\pgfsys@animation@val@scale|.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@scale{0.5}{2}
  \pgfsys@animate{scale}
}
\end{codeexample}
\end{sysanimateattribute}

\begin{sysanimateattribute}{rotate}
  Adds a rotation animation around the origin.
  
  Specify values with |\pgfsys@animation@val@scalar|.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@scalar{90}
  \pgfsys@animate{rotate}
}
\end{codeexample}
\end{sysanimateattribute}

\begin{sysanimateattribute}{skewx}
  Adds an animation of a skewing of the canvas along the
  $x$-axis. Unlike the |slant| options of \tikzname, the skew is given
  in degrees.
  
  Specify values with |\pgfsys@animation@val@scalar|.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@scalar{45}
  \pgfsys@animate{skewx}
}
\end{codeexample}
\end{sysanimateattribute}

\begin{sysanimateattribute}{skewy}
  Adds an animation of a skewing of the canvas along the $y$-axis.
  
  Specify values with |\pgfsys@animation@val@scalar|.
\end{sysanimateattribute}

\begin{sysanimateattribute}{motion}
  Works a bit like |\pgfsys@animation@translate|: It also adds an
  animated shift transformation of the canvas. However, itstead of
  specifying some shift coordinates as values, you now specify a whole
  path (which may include curves). The effect is that an animated
  translate transformation for the different points on this path gets
  installed. Furthermore, if you use |\pgfsys@animation@rotatealong|, an
  additional adaptive rotation transformation will be added so that
  the animated graphic scope ``points along'' the path.

  You specify the path along which you wish to move objects along
  using |\pgfsys@animation@movealong|. You use the timeline to specify
  how far the object gets moved along this path using scalar values
  where |0| is the beginning of the path and |1| is the end. Thus,
  setting the timeline to the scalar value of |0| at time $t_0$ and to
  |1| at time $t_1$ will cause the object o move along the complete
  path between times $t_0$ and $t_1$.
  
  Specify values with |\pgfsys@animation@val@scalar|.
    
  \begin{command}{\pgfsys@animation@movealong\marg{path}}
    Defines the \meta{path} along which the motion will occur. It will
    simply be executed and must call |\pgfsys@lineto| and similar
    path-construction commands, but should not call other commands.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@movealong{%
    \pgf@relevantforpicturesizefalse
    \pgfpathmoveto{\pgfpointxy{0}{0}} \pgfpathlineto{\pgfpointxy{0}{1}}
    \pgfpatharc{180}{90}{1cm}}
  \pgfsys@animation@val@scalar{1}
  \pgfsys@animate{motion}
}
\end{codeexample}
  \end{command}

  \begin{command}{\pgfsys@animation@norotatealong}
    Indicates that no additional rotation should be added during the
    movement. This is the default.
  \end{command}
  
  \begin{command}{\pgfsys@animation@rotatealong}
    Indicates that the to-be-animated group should be rotated
    automatically so that it points along the path as time
    progresses. This option is only applicable to motion animations.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@rotatealong
  \pgfsys@animation@movealong{%
    \pgf@relevantforpicturesizefalse
    \pgfpathmoveto{\pgfpointxy{0}{0}} \pgfpathlineto{\pgfpointxy{0}{1}}
    \pgfpatharc{180}{90}{1cm}}
  \pgfsys@animation@val@scalar{1}
  \pgfsys@animate{motion}
}
\end{codeexample}
  \end{command}

\end{sysanimateattribute}


\begin{sysanimateattribute}{viewbox}
  Adds an animation of the view box. The graphic scope to which this
  animation is added must have been created using
  |\pgfsys@viewboxmeet| or |\pgfsys@viewboxslice|; adding it to other
  scopes has no effect. Note that this command does \emph{not}
  change or animate the scope's transformation matrix -- it only animates the
  ``what we see through the view box.''
  
  Specify values with |\pgfsys@animation@val@viewbox|.
\begin{codeexample}[width=5cm]
\animationexample{my view}{view}{
  \pgfsys@animation@val@viewbox{15mm}{-15mm}{27mm}{8mm}%
  \pgfsys@animate{viewbox}
  \scoped [xshift=2cm] {
    \draw [red] (-1,-2) rectangle (1,2) node [font=\scriptsize,
               below left, align=right] {original\\ view\\ box};  
    \scoped [meet={(-1,-2) (1,2)}, name=my view]  {
      \draw (-5mm,-15mm) rectangle (7mm,8mm)
        node [font=\scriptsize, align=right, below left]
          {target\\ view\\ box};  ;  
      \filldraw (0,0) circle [radius=3mm];
} } }
\end{codeexample}
\end{sysanimateattribute}


\subsubsection{Commands for Specifying the Target Object}

\begin{command}{\pgfsys@animation@whom\marg{id}\marg{type}}
  Sets the target of the animation. The \marg{id} must previously have
  been created using |\pgfsys@new@id|, \marg{type} must be a type (the
  empty type is also allowed). See Section~\ref{section-sys-id} for
  details on ids and types.
\end{command}




\subsubsection{Commands for Specifying Timelines: Specifying Times}

Animations are specified using \emph{timelines}, which are functions
mapping times to values for these times. The functions are cubic
splines, which are specified using time--value pairs plus control
points.

In order to specify a time--value pair, you first use the command
|\pgfsys@animation@time| to specify a time. Next, you use
|\pgfsys@animation@val@...| to specify a value, which adds the
time--value pair to the timeline. Note that the times must be given in
non-decreasing order. Between time--value pairs, the values are
interpolated using a spline. 

The first and last times of the timeline are a bit special: The
timeline starts on the first time and the duration of the timeline is
the difference between the first and last time. ``Starting'' on the
start time actually means that any beginnings (see the commands for
specifying beginnings and endings) get as offset the start time;
similarly end times are offset by this value.

\begin{command}{\pgfsys@animation@time\marg{time}\marg{entry spline
      control x}\marg{entry spline  control y}\marg{exit spline
      control x}\marg{exit spline control y}}
  The \meta{time} is a number representing seconds (so |0.5| means
  500\,ms).

  The spline between a time--value pair and the next is specified
  using the four parameters following the time. The first two of these
  specify the second control point of the interval preceding the
  time--value pair (called the ``entry'' control point), the last two
  parameters specify the first control point of the interval following
  the pair (called the ``exit'' control point). Consider for instance,
  the following calls:
\begin{codeexample}[code only]
\pgfsys@animation@time{10}{0.1}{0.2}{0.3}{0.4}
\pgfsys@animation@val@scalar{100}
\pgfsys@animation@time{15}{0.5}{0.6}{0.7}{0.8}
\pgfsys@animation@val@scalar{200}
\end{codeexample}
  This will create (at least) the time interval $[10\,\mathrm
  s,15\,\mathrm s]$ and the control points for this interval will be
  $(0.3,0.4)$ and $(0.5,0.6)$.

  Control points are specified in a different ``coordinate'' system
  from the time--value pairs themselves: While the time--value pairs
  are specified using a number representing seconds and a value using
  some special commands, the control points are specified as numbers
  between $0$ and $1$, each time representing a fraction of the time
  interval or the value interval. In the example, the time interval is $[10\,\mathrm
  s,15\,\mathrm s]$ and the value interval is $[100,200]$. This means
  that a control point of $(0.3,0.4)$ actually refers to the
  time--value $(11.5\,\mathrm s,140)$. The ``time--value curve'' in
  the interval thus ``\texttt{(10s,100) .. controls (11.5s,140) and
    (12.5s,160) .. (15s,200)}''.

  Note that by setting the control points always to $(1,1)$ and
  $(0,0)$ you get a linear interpolation between time--value pairs.

  Two special cases are the following: When the two last parameters,
  the exit spline, take the special values |stay| and |0|, the
  attribute's value ``stays'' until the next value for the next time
  (it then ``jumps'' to the next value then). This corresponds,
  roughly, to an ``infinite'' \meta{exit spline control x}.
  Similarly, when the entry spline parameters take the special values
  |jump| and |1|, the value immediately jumps from the previous value to
  the next value when the previous value was specified.
  
  \begin{command}{\pgfsys@animation@spline}
    Specifies that the value of the to-be-animated attribute varies
    according to the splines as described above. This is the default.
\begin{codeexample}[width=2cm]
\animationtimingexample{node}{}{
  \pgfsys@animation@time{0}{1}{1}{0.5}{0}
  \pgfsys@animation@val@translate{0pt}{0pt}
  \pgfsys@animation@time{1}{1}{1}{0}{0}
  \pgfsys@animation@val@translate{0cm}{-2cm}
  \pgfsys@animation@time{2}{0.5}{1}{0}{0}
  \pgfsys@animation@val@translate{2mm}{-2cm}
  \pgfsys@animate{translate}}
\end{codeexample}
  \end{command}

  \begin{command}{\pgfsys@animation@paced\marg{start time}\marg{end time}}
    When set, the time--value curve is no longer controlled by the
    provided times and splines (these are ignored). Instead, the
    animation is ``paced'' so that the speed of the change of the
    value is constant. This is mainly useful for motion animations.

    You can use the \meta{start time} parameter to specify the start
    time of the timeline explicitly, similarly for the \meta{end
      time}. When omitted, the normal start and end times are used.
\begin{codeexample}[width=2cm]
\animationtimingexample{node}{}{
  \pgfsys@animation@time{0}{1}{1}{0.5}{0}
  \pgfsys@animation@val@translate{0pt}{0pt}
  \pgfsys@animation@time{1}{1}{1}{0}{0}
  \pgfsys@animation@val@translate{0cm}{-2cm}
  \pgfsys@animation@time{2}{0.5}{1}{0}{0}
  \pgfsys@animation@val@translate{2mm}{-2cm}
  \pgfsys@animation@paced{}{}
  \pgfsys@animate{translate}}
\end{codeexample}
  \end{command}
 
\end{command}


\subsubsection{Commands for Specifying Timelines: Specifying Values}

The following commands are used to specify the values of a
timeline. Each use of one of the following commands adds one
time--value pair to the timeline. Which of the commands must be used
depends on the type of the to-be-animated attribute (see the
|\pgfsys@animate| command instances, which list the command that must be
used). 


\begin{command}{\pgfsys@animation@val@text\marg{text}}
  Creates a time--value pairs where the value is some text. Which
  texts are permissible depends on the to-be-animated attribute.
\end{command}

\begin{command}{\pgfsys@animation@val@scalar\marg{number}}
  Creates a time--value pairs where the value is a number like |0.5|
  or |-2.25|.
\end{command}

\begin{command}{\pgfsys@animation@val@dimension\marg{dimension}}
  Creates a time--value pairs where the value is a \TeX\ dimension
  like |0.5pt| or |-2in|.
\end{command}

\begin{command}{\pgfsys@animation@val@color@rgb\marg{red}\marg{green}\marg{blue}}
  Creates a time--value pairs where the value is color
  specified by three fractional values between 0 and 1 for the red,
  the green, and the blue part.
\end{command}

\begin{command}{\pgfsys@animation@val@color@cmyk\marg{cyan}\marg{magenta}\marg{yellow}\marg{black}}
  Creates a time--value pairs where the value is color
  specified by four fractional values between 0 and 1 for the cyan,
  magenta, yellow, and black part.
\end{command}

\begin{command}{\pgfsys@animation@val@color@cmy\marg{cyan}\marg{magenta}\marg{yellow}}
  Like the |\pgfsys@animation@color@cmyk| only without the black part.
\end{command}

\begin{command}{\pgfsys@animation@color@gray\marg{gray value}}
  Creates a time--value pairs where the value is gray value (a
  fraction between 0 and 1).
\end{command}

\begin{command}{\pgfsys@animation@val@path\marg{code}}
  Creates a time--value pairs where the value is path. The \meta{code}
  should call path construction commands like |\pgfsys@lineto|. Note
  that when you animate a path, each value (each path) should have the
  same structure, only the numbers may differ.  
\end{command}

\begin{command}{\pgfsys@animation@val@translate\marg{x dimension}\marg{y dimension}}
  Creates a time--value pairs where the value is a coordinate. The
  dimensions must be \TeX\ dimensions.
\end{command}

\begin{command}{\pgfsys@animation@val@scale\marg{x scale}\marg{y scale}}
  Creates a time--value pairs where the value is pair of scalar values.
\end{command}

\begin{command}{\pgfsys@animation@val@viewbox\marg{$x_1$}\marg{$y_1$}\marg{$x_2$}\marg{$y_2$}}
  Creates a time--value pairs where the value is view box. The lower
  left corner is given by $(x_1,y_1)$, consisting of two \TeX\
  dimensions, and the upper right corner is $(x_2,y_2)$.
\end{command}


\begin{command}{\pgfsys@animation@val@dash\marg{pattern}\marg{phase}}
  Creates a time--value pairs where the value is dash pattern and
  phase with the same syntax as |\pgfsys@setdash|.
\end{command}


\subsubsection{Commands for Specifying Timing: Repeats}


\begin{command}{\pgfsys@animation@repeat\marg{number of times}}
  Specifies that the animation should repeat the specified
  \meta{number of times}, which may be a fractional number.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@repeat{2.5}
  \pgfsys@animate{translate} }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@repeat@indefinite}
  Specifies that the animation should repeat indefinitely.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@repeat@indefinite
  \pgfsys@animate{translate} }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@repeat@dur\meta{seconds}}
  Specifies that the animation should repeat until \meta{seconds} have
  elapsed. 
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@repeat@dur{5}
  \pgfsys@animate{translate} }
\end{codeexample}
\end{command}




\subsubsection{Commands for Specifying Timing: Beginning and Ending}

Normally, animations start when a graphic is displayed. Using the
following commands, you can change this behavior: For instance, you
can specify that the animation should start when, say, some button has
been pressed or a key has been hit. Similarly, you can also use the
commands to specify that the animation should stop early, for instance
when a button is pressed.

Note that all of the commands for specifying a nonstandard begin (or
end) of an animation's timeline refer to when the time $0\,\mathrm s$
of the timeline should actually be. If the first time--value point for
a timeline is at, say, 2\,s and you specify that the begin of the
animation is one second after the click of a button, the attribute
will attain the value specified by the time--value point three seconds
after the button has been pressed.

All of the following commands take either the text |begin| or |end| as
their last argument.

You can call the commands several times. This will result in several
different possible beginnings (or endings).

\begin{command}{\pgfsys@animation@offset\marg{time offset}\marg{begin or end}}
  Specifies that (in addition to any other beginnings or endings) the
  animation's timeline should begin (or end) \meta{time offset} many
  seconds after the graphic is shown. For instance, in the next
  example the animation will start automatically after 5\,s \emph{or}
  when then button is pressed.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@offset{5}{begin}
  \pgfsys@animate{translate} }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@syncbegin\marg{sync base
      id}\marg{type}\marg{time offset}\marg{begin or end}}
  Specifies that the animation should begin \meta{time offset} many
  seconds after the \meta{sync base id} with the given \meta{type} has
  begun. Here, the \meta{sync base id} must have been obtained using
  |\pgfsys@new@id|.

  The idea behind a sync base is that you setup an animation and name
  it, other animations can start alongside this animation. An
  animation whose sole purpose is to orchestrate other animations in
  this way is called a \emph{sync base}. 
\end{command}

\begin{command}{\pgfsys@animation@syncend\marg{sync base
      id}\marg{type}\marg{time offset}\marg{begin or end}}
  Works like |\pgfsys@animation@syncbegin| only the animation begin
  (or ends) when the sync base ends.
\end{command}

\begin{command}{\pgfsys@animation@event\marg{id}\marg{type}\marg{event
      name}\marg{time offset}\marg{begin or end}}
  Specifies that the animation should begin (or end) \meta{time
    offset} many seconds after a certain \emph{event} has
  occurred. Which events are possible depends on the specific output
  language, here are the events currently supported in \textsc{svg}:
  \begin{itemize}
  \item |click| occurs when the object with the given \meta{id} and
    \meta{type} has been clicked.
  \item |focusin| and |focusout| occur when the focus enters or leaves
    the object.
  \item |mouseup|, |mousedown|, |mouseover|, |mousemove|, and
    |mouseout| occur when the mouse is pressed up or down on the
    object, moved onto the object, moved over the object, or moved off
    the object.
  \end{itemize}
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@event{\nodeid}{}{mouseup}{}{begin}
  \pgfsys@animate{translate} }
\end{codeexample}
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@event{\nodeid}{}{mousedown}{}{begin}
  \pgfsys@animate{translate} }
\end{codeexample}
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@event{\nodeid}{}{mouseover}{}{begin}
  \pgfsys@animate{translate} }
\end{codeexample}
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@event{\nodeid}{}{mousemove}{}{begin}
  \pgfsys@animate{translate} }
\end{codeexample}
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@event{\nodeid}{}{mouseout}{}{begin}
  \pgfsys@animate{translate} }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@repeat@event\marg{id}\marg{type}\marg{repeat
      count}\marg{time offset}\marg{begin or end}}
  The animation begins (or end) with a certain offset when another
  animation has reached a certain repeat count. 
\begin{codeexample}[width=4cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@repeat@dur{5}
  \pgfsys@new@id{\animationid}
  \pgfsys@use@id{\animationid}
  \pgfsys@animate{translate} 
  \global\let\animationid\animationid }
\tikz {
  \pgfidrefnextuse{\objid}{other}
  \pgfsys@animation@whom{\objid}{}
  \pgfsys@animation@time{0}{1}{1}{0}{0}
  \pgfsys@animation@val@current
  \pgfsys@animation@time{2}{1}{1}{0}{0}
  \pgfsys@animate{translate} 
  \node [fill=red, text=white, circle] (other) {Other}; }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@accesskey\marg{character}\marg{time offset}\marg{begin or end}}
  Begin or end the animation when a certain key is pressed. Note that
  this event may not be supported by some browsers for security
  reasons (prevent key loggers). 
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@accesskey{s}{}{begin}
  \pgfsys@animate{translate} 
}
\end{codeexample}
\end{command}



\subsubsection{Commands for Specifying Timing: Restart Behaviour}

\begin{command}{\pgfsys@animation@restart@always}
  Defines that the animation can be restarted at any time. This is the
  default.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@restart@always
  \pgfsys@animate{translate} }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@restart@never}
  Defines that the animation cannot be restarted once it has run.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@restart@never
  \pgfsys@animate{translate} }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@restart@whennotactive}
  Defines that the animation cannot be restarted while it is running.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@restart@whennotactive
  \pgfsys@animate{translate} }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@freezeatend{}}
  When an animation ends, the question is whether the ``effect'' of
  the animation (like changing a color or translating the coordinate
  system) should disappear or ``remain in force.'' Using this key, you
  specify that at the end of the animation the last value of the
  attributes stayes in effect.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@freezeatend
  \pgfsys@animate{translate} }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@removeatend{}}
  The opposite of |\pgfsys@animation@freezeatend|. This is the default.
\begin{codeexample}[width=2cm]
\animationexample{node}{}{
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@removeatend
  \pgfsys@animate{translate} }
\end{codeexample}
\end{command}


\subsubsection{Commands for Specifying Accumulation}

Animations specify how an attribute of an object changes over
time. When more than one animation changes the same value at the same
time, either one animation ``wins'' or their effects ``add up.''

\begin{command}{\pgfsys@animation@sum{}}
  Specifies that the animation should add its effect to any previous
  animation of the same object.
\begin{codeexample}[width=2cm]
\animationtimingexample{node}{}{
  \pgfsys@animation@time{0}{1}{1}{0}{0}
  \pgfsys@animation@val@translate{0cm}{0cm}
  \pgfsys@animation@time{2}{1}{1}{0}{0}
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@sum
  \pgfsys@animate{translate} 
  \pgfsys@animate{translate} % Second animation adds to first
}
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@replace{}}
  Specifies that the animation should override any previous animations
  of the same object. 
\begin{codeexample}[width=2cm]
\animationtimingexample{node}{}{
  \pgfsys@animation@time{0}{1}{1}{0}{0}
  \pgfsys@animation@val@translate{0cm}{0cm}
  \pgfsys@animation@time{2}{1}{1}{0}{0}
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@replace
  \pgfsys@animate{translate} 
  \pgfsys@animate{translate} % Second animation overrides first
}
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@accumulate{}}
  Specifies that each repeat of an animation works as if the last
  values attained during previous repeats are added to the current value.
\begin{codeexample}[width=2cm]
\animationtimingexample{node}{}{
  \pgfsys@animation@time{0}{1}{1}{0}{0}
  \pgfsys@animation@val@translate{0cm}{0cm}
  \pgfsys@animation@time{2}{1}{1}{0}{0}
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@accumulate
  \pgfsys@animation@repeat@dur{5}
  \pgfsys@animate{translate}  }
\end{codeexample}
\end{command}

\begin{command}{\pgfsys@animation@noaccumulate{}}
  Specifies that each repeat resets the to-be-animated value.
\begin{codeexample}[width=2cm]
\animationtimingexample{node}{}{
  \pgfsys@animation@time{0}{1}{1}{0}{0}
  \pgfsys@animation@val@translate{0cm}{0cm}
  \pgfsys@animation@time{2}{1}{1}{0}{0}
  \pgfsys@animation@val@translate{0cm}{-1cm}
  \pgfsys@animation@noaccumulate
  \pgfsys@animation@repeat@dur{5}
  \pgfsys@animate{translate}  }
\end{codeexample}
\end{command}






\subsection{Object Identification System Commands}
\label{section-sys-id}

The system layer provides commands for adding identification labels
(ids) to different objects in a graphic. These can be used for
hyperlinking, which is needed for instance in conjunction with
animations.

The following ``objects'' can get an id assigned to them:
\begin{enumerate}
\item Graphic scopes (namely when |\pgfsys@begin@idscope| is called),
\item view boxes (namely when |\pgfsys@viewboxmeet| or |\pgfsys@viewboxslice| are called),
\item paths (namely when |\pgfsys@fill|, |\pgfsys@stroke|, and so on are called),
\item text boxes (namely when |\pgfsys@hbox| or |\pgfsys@hboxsynced| is called), and
\item animations (namely when |\pgfsys@animate| is called).
\end{enumerate}


Creating and using ids is a two-step process. First, you create the
id using |\pgfsys@new@id|, which stores a fresh id in a macro. You can
now pass this id around and clone it. Then, at some point, you wish
one of the above objects to actually get this id. For this, you use
|\pgfsys@use@id| just \emph{before} the object since this command
always influences the \emph{next} object.

The basic id management gets more powerful when you use \emph{id
  types}. The idea is as follows: In reality, the objects from above
do not get assigned only an id, but rather a combination of an id and
a type -- and you can set the type independently of the id. This is
used, for instance, to allow easy access to the different parts of a
node in animations: Each node has a single id, but consists of several
graphic objects (normally, at least a background path and a
text). Each of these uses the same underlying id of the node, but the
path has the type |path| (actually |background.path|) while the text
has the type |text|. The advantage is that for each node only one id
must be stored instead of a great number of the many different
possible parts of a node.

\begin{command}{\pgfsys@new@id\marg{macro}}
  Creates a new id for later use and stores it in \meta{macro}. It is
  an internal text created by the driver and may not be changed or
  modified. 
\end{command}

\begin{command}{\pgfsys@use@id\marg{id}}
  ``Uses'' an id previously created using |\pgfsys@new@id|. This
  causes the \emph{next} graphic object to get the \meta{id} (not the
  current one). Once used, the id-type-pair becomes \emph{invalid} and
  will not be attached to any other graphics objects. It is, however,
  not an error to try this. If \meta{id} is empty, no id-type-pair is
  attached to the next object.
\end{command}

\begin{command}{\pgfsys@use@type\marg{type}}
  Changes the type used with the next graphic object.
  As mentioned earlier, the id assigned to the next object is actually
  a pair consisting of the currently used id and the currently used
  type. 
\end{command}

\begin{command}{\pgfsys@append@type\marg{text}}
  Appends the \meta{text} to the current type. 
\end{command}

\begin{command}{\pgfsys@push@type}
  Pushes the current type on a global ``stack of types'' without
  opening a \TeX\ scope. The is useful when you temporarily wish to
  change the type (for instance, by appending something to it), but
  you cannot create a new scope.
\end{command}

\begin{command}{\pgfsys@pop@type}
  Restores the most recently pushed type.
\end{command}

\begin{command}{\pgfsys@begin@idscope}
  Starts a (graphics) scope whose sole purpose is to assign it an
  id-type-pair so that it can be referenced later. Note that this
  command does not always produce a graphics scope: If not id is
  currently in use or if the id-type-pair has already been used,
  a graphic scope may or may not be created as defined by the driver
  (but always a \TeX\ scope). This allows drivers to minimize the
  number of graphic scopes created.

  When an id scope is created, any code that has been ``attached'' to
  it using |\pgfsys@attach@to@id| gets executed, see that command.

  Note that |\pgfsys@beginscope| does not use the current
  id-type-pair. You need to call this command to attach an id to a
  group. 
\end{command}

\begin{command}{\pgfsys@end@idscope}
  Ends the graphics id scope started by |\pgfsys@end@idscope|. It must
  nest correctly with other graphic scopes and \TeX\ scopes.
\end{command}


\begin{command}{\pgfsys@attach@to@id\marg{id}\marg{type}\marg{begin
      code}\marg{end code}\marg{setup code}}
  Attaches codes to the \meta{id}-\meta{type}-pair, where
  \meta{id} must have been created using |\pgfsys@new@id|. The effect
  is that just before the id scope for this pair is created, the
  \meta{setup code} is executed, then the scope is started, then the
  \meta{begin code} is executed at the beginning, and, finally,
  \meta{end code} gets executed just before the scope ends. Multiple
  calls of this macro accumulated.
\end{command}


\subsection{Reusable Objects System Commands}

\begin{command}{\pgfsys@invoke\marg{literals}}
  This command gets protocolled literals and should insert them into
  the |.pdf| or |.dvi| file using an appropriate |\special|.
\end{command}

\begin{command}{\pgfsys@defobject\marg{name}\marg{lower
      left}\marg{upper right}\marg{code}}
  Declares an object for later use. The idea is that the object can be
  precached in some way and then be rendered more quickly when used
  several times. For example, an arrow head might be defined and
  prerendered in this way.

  The parameter \meta{name} is the name for later use. \meta{lower
  left} and \meta{upper right} are \pgfname\ points specifying a bounding
  box for the object. \meta{code} is the code for the object. The code
  should not be too fancy.

  This command has a default implementation and need not be
  implemented by a driver file.
\end{command}

\begin{command}{\pgfsys@useobject\marg{name}\marg{extra code}}
  Renders a previously declared object. The first parameter is the
  name of the object. The second parameter is extra code that
  should be executed right \emph{before} the object is
  rendered. Typically, this will be some transformation code.

  This command has a default implementation and need not be
  implemented by a driver file.
\end{command}


\subsection{Invisibility System Commands}

All drawing or stroking or text rendering between calls of the
following commands should be suppressed. A similar effect can be
achieved by clipping against an empty region, but the following
commands do not open a graphics scope and can be opened and closed
``orthogonally'' to other scopes.

\begin{command}{\pgfsys@begininvisible}
  Between this command and the closing |\pgfsys@endinvisible| all
  output should be suppressed. Nothing should be drawn at all, which
  includes all paths, images and shadings. However, no groups (neither
  \TeX\ groups nor graphic state groups) should be opened by this
  command.

  This command has a default implementation and need not be
  implemented by a driver file.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}

\begin{command}{\pgfsys@endinvisible}
  Ends the invisibility section, unless invisibility blocks have been
  nested. In this case, only the ``last'' one restores visibility.

  This command has a default implementation and need not be
  implemented by a driver file.

  This command is protocolled, see Section~\ref{section-protocols}.
\end{command}



\subsection{Page Size Commands}

The following commands can be used to set the page size of a document
in a ``portable'' way. Note, however, that many packages also (try to)
set the page size.

These commands are typically not given inside a |{pgfpicture}|, but on
the outer level of compilation.

\begin{command}{\pgfsys@papersize\marg{width}\marg{height}}
  Inserts the necessary |\special|s for the current driver into the
  output stream to ``locally'' change the page size. Whether such a
  ``local'' change is possible depends strongly on the driver. For
  instance, |dvips| will honor the first call to this command that is
  part of the shipped-out document and will ignore all other uses. In
  contrast, |pdftex| will use the current value of the paper size for
  each page and, additionally, setting the papersize is local to the
  current \TeX\ group.
\end{command}

\begin{command}{\pgfsys@global@papersize\marg{width}\marg{height}}
  Like the previous command, only for drivers where setting the paper
  size parameters is a \TeX-group-local operation, |\global| is
  prefixed to the setting of the page sizes. 
\end{command}

\begin{command}{\pgfsys@thepageheight}
  This macro expands to the current page's height, provided \LaTeX\ is
  used, otherwise a best guess is returned (currently just |\the\vsize|). 
\end{command}

\begin{command}{\pgfsys@thepagewidth}
  As above.
\end{command}

\subsection{Position Tracking Commands}

The following commands are used to determine the position of text on a
page. This is a rather complicated process in general since at the
moment when the text is read by \TeX, the final position cannot be
determined, yet. For example, the text might be put in a box which is
later put in the headline or perhaps in the footline or perhaps even
on a different page.

For these reasons, position tracking is typically a two-stage
process. In a first stage you indicate that a certain position is of
interest by \emph{marking} it. This will (depending on the details of
the backend driver) cause page coordinates or this position to be
written to an |.aux| file when the page is shipped. Possibly, the
position might also be determined at an even later stage. Then, on a
second run of \TeX, the position is read from the |.aux| file and can
be used.

\begin{command}{\pgfsys@markposition\marg{name}}
  Marks a position on the page. This command should be given while
  normal typesetting is done such as in
\begin{codeexample}[code only]
The value of $x$ is \pgfsys@markposition{here}important.
\end{codeexample}
  It causes the position |here| to be saved when the page is shipped
  out.
\end{command}

\begin{command}{\pgfsys@getposition\marg{name}\marg{macro}}
  This command retrieves a position that has been marked on an earlier
  run of \TeX\ on the current file. The \meta{macro} must be a macro
  name such as |\mymacro|. It will be redefined such that it is
  \begin{itemize}
  \item either just |\relax| or
  \item a |\pgfpoint...| command.
  \end{itemize}
  The first case will happen when the position has not been marked at
  all or when the file is typeset for the first time, when the
  coordinates are not yet available.

  In the second case, executing \meta{macro} yields the position on
  the page that is to be interpreted as follows: A coordinate like
  |\pgfpoint{2cm}{3cm}| means ``2cm to the right and 3cm up from the
  origin of the page.'' The position of the origin of the page is not
  guaranteed to be at the lower left corner, it is only guaranteed
  that all pictures on a page use the same origin.

  To determine the lower left corner of a page, you can call
  |\pgfsys@getposition| with \meta{name} set to the special name
  |pgfpageorigin|. By shifting all positions by the amount returned by
  this call you can position things absolutely on a page.

  \example Referencing a point of the page:
\begin{codeexample}[code only]
The value of $x$ is \pgfsys@markposition{here}important.

Lots of text.

\hbox{\pgfsys@markposition{myorigin}%
\begin{pgfpicture}
  % Switch of size protocol
  \pgfpathmoveto{\pgfpointorigin}
  \pgfusepath{use as bounding box}

  \pgfsys@getposition{here}{\hereposition}
  \pgfsys@getposition{myorigin}{\thispictureposition}

  \pgftransformshift{\pgfpointscale{-1}{\thispictureposition}}
  \pgftransformshift{\hereposition}

  \pgfpathcircle{\pgfpointorigin}{1cm}
  \pgfusepath{draw}
\end{pgfpicture}}
\end{codeexample}
\end{command}


\subsection{Internal Conversion Commands}

The system commands take \TeX\ dimensions as input, but the dimensions
that have to be inserted into \pdf\ and PostScript files need to be
dimensionless values that are interpreted as multiples of
$\frac{1}{72}\mathrm{in}$. For example, the \TeX\ dimension $2bp$
should be inserted as |2| into a \pdf\ file and the \TeX\ dimension
$10\mathrm{pt}$ as |9.9626401|. To make this conversion easier, the following
command may be useful:

\begin{command}{\pgf@sys@bp\marg{dimension}}
  Inserts how many multiples of $\frac{1}{72}\mathrm{in}$ the
  \meta{dimension} is into the current protocol stream (buffered).

  \example |\pgf@sys@bp{\pgf@x}| or |\pgf@sys@bp{1cm}|.
\end{command}

Note that this command is \emph{not} a system command that can/needs
to be overwritten by a driver.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "pgfmanual"
%%% End:
